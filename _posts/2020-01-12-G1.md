---
layout: post
title: 'JVM G1垃圾回收'
---

## 简介

G1（Garbage-First）垃圾回收器是在jdk7版本开始被引进的，它的特性在于能够尽可能的满足用户对停顿时间的要求同时还保持较高的吞吐。G1的定位是取代CMS，相比CMS，G1能够更有效的避免碎片化，同时可以让用户指定预期的停顿时间。

## G1的机制

G1同样是分代的垃圾回收，但是不同的是G1把整个堆分成了大小相等的块（称为region），每个region可以被分配为不同的角色（young、eden、old等等），这意味着不同代的内存大小是不固定的，可以灵活地调整。

G1会在jvm启动时确定region size（最小1M，最大32M），通常G1会尽量把堆分为2048个相同大小的region，具体的region size由此计算，也可以在jvm参数里显示指定。不同的region会被分配到不同的逻辑角色，比如eden/old，同一个逻辑角色的不同region也不一定是连续的。

G1的运行机制与CMS类似，G1会进行并发的全局标记来判断对象的存活与否，在标记结束后，G1就能得知哪些region中的垃圾最多，然后就先回收这部分region，这就是G1的名字的由来。G1采用了一个停顿时间预测的模型来尽可能满足用户指定的停顿时间，根据用户指定的停顿时间来选择要回收哪些region。

G1在进行垃圾回收时采用的是复制算法，G1会把各个region中残留的存活对象复制到单独的region中，这样在回收过程中就完成了内存的整理。为了降低复制过程中停顿的时间，整个复制过程是并行的，而CMS并不会进行内存整理，ParallelOld则是会直接整理整个堆，显然会明显增加停顿时间。

### Remembered Sets和Collection Sets

RSet用于记录指向某个region的引用，每个region对应一个RSet。CSet记录了GC过程中会被回收的region，CSet中存活的对象在GC过程中都会被复制。Rset和Cset都是为了帮助GC而产生的额外的对象。

## G1的各个阶段

### young gc

发生young gc时，存活的对象被复制到survivor区，如果对象的年龄超过阈值，那么会把它晋升到old区。整个young gc过程中是STW的，同时也会重新计算出下一次GC时的eden区和survivor区的大小，计算过程中也会考虑用户指定的目标停顿时间。因为region的设计，要调整各个分区的大小实际上非常容易。

### concurrent marking cycle

并发标记是G1中的一个重要阶段，这个阶段包括若干个步骤，通过并发标记来收集各个region的使用情况等信息，协助达到用户指定的停顿时间。

#### initial mark（STW）

这一步是和young gc一起顺带着执行的，首先标记出gc roots直接可达的对象，

#### root region scanning

young gc过后，survivor中的对象都被标记为root region，这时扫描由survivor区直接可达的old区并标记。这一阶段必须在新一轮的young gc前执行完毕。如果这时又需要young gc，那么会等待扫描完成才会进行。

#### concurrent marking

扫描整个堆，标记存活的对象，整个阶段是与应用程序并行的，可能被young gc打断。

#### remark（STW）

对标记的结果进行修正，所以这个阶段需要暂停。这个过程中G1用了一个SATB的算法，宣称比CMS的类似步骤更快。

#### cleanup（STW）

这阶段会清理各个region，同时更新Rset，如果有空的region就把它释放掉。

#### copying（STW）

把存活的对象拷贝到新的region。

### 并发标记总结

+ 并发标记
    + 存活对象的信息是在运行时并行地计算的
    + 在复制阶段，G1会根据每个region内存活对象的信息确定哪些region优先被回收
    + 没有sweep过程CMS
+ 重标记
    + SATB算法
    + 空的region会被直接回收
+ 复制/清理
    + young和old区同时进行回收
    + 会根据情况选择特定的old区region进行回收

### 混合GC

在经历了一个完整的标记周期过后，G1会在下一次young gc的时刻转换成混合gc，混合gc下，G1可能会把一部分old区的region加入Cset中，利用young gc的算法清理一部分old region。当G1回收了足够多的old region，又会重新回到young gc，直到下一次并发标记周期完成。

## 总结

G1的目标是要代替CMS，它把整个堆空间划分成了不同的region来进行管理，使得分配和回收更加灵活。G1的主要活动包括young gc、mixed gc以及并发标记，它会根据用户指定的目标停顿时间来决定要对哪些内存区域进行回收。官方里提到的SATB、Rset以及Cset等等概念需要再详细了解。