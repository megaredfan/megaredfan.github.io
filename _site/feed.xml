<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-12-29T19:55:53+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">熊纪元的博客</title><subtitle>think digital and be human</subtitle><entry><title type="html">TCP BBR简介</title><link href="http://localhost:4000/2019/12/29/TCP-BBR.html" rel="alternate" type="text/html" title="TCP BBR简介" /><published>2019-12-29T00:00:00+08:00</published><updated>2019-12-29T00:00:00+08:00</updated><id>http://localhost:4000/2019/12/29/TCP%20BBR</id><content type="html" xml:base="http://localhost:4000/2019/12/29/TCP-BBR.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;TCP BBR是由来自Google的 Neal Cardwell 和 Yuchung Cheng 发表的新的TCP拥塞控制算法，目前已经在Google内部大范围使用并且随着linux 4.9版本正式发布。不过我个人第一次接触到BBR却是在搭建上网工具的时候，个人体感开启了BBR之后的访问速度明显提高，在这里主要总结一下从网上了解到的相关知识。&lt;/p&gt;

&lt;h2 id=&quot;bbr简介&quot;&gt;BBR简介&lt;/h2&gt;

&lt;p&gt;BBR的名称实际上是bottleneck bandwith and round-trip propagation time的首字母缩写，表明了BBR的主要运行机制：通过检测带宽和RTT这两个指标来进行拥塞控制。 BBR算法的主要特点有以下几个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BBR不考虑丢包，因为丢包（在现在这个时代）并不一定是网络出现拥塞的标志了&lt;/li&gt;
  &lt;li&gt;BBR依赖实时检测的带宽和RTT来决定拥塞窗口的大小：窗口大小 = 带宽 * RTT&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;丢包不一定等于发生拥塞&quot;&gt;丢包不一定等于发生拥塞&lt;/h3&gt;

&lt;p&gt;在1988发表的论文《Congestion Avoidance and Control》中，Van Jacobson就提出丢包可以作为发生拥塞的信号，在当时的硬件性能下这个推论是成立的，后续的诸多拥塞控制算法也都是按照这个思路来实现（当然也有例外比如Vegas和Westwood），而如今网卡带宽已经从Mbps增长到了Gbps，丢包与拥塞这两者之间的关联关系也就变得微弱了。&lt;/p&gt;

&lt;p&gt;在现在网络状况下，丢包可能是由于拥塞，也有可能是因为错误。在数据中心内部，错误丢包率并不高（约在十万分之一）；而在广域网上错误丢包率则高得多。更重要的是，在有一定错误丢包率的长肥管道（带宽大、延时高的网络）中，传统的拥塞控制算法会将发送速率收敛到一个比较小的值，导致网络利用率非常低。&lt;/p&gt;

&lt;p&gt;另外，网络链路中很多设备都会有缓冲，用于吸收网络中的波动，提高转发成功率，而传统的基于丢包的拥塞控制算法感知到丢包时，这些缓冲却早已被填满了，这个问题成为bufferbloat（缓冲区膨胀）。而bufferbloat带来的影响主要有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;延时会增加，同时缓冲越大延时增加得越多&lt;/li&gt;
  &lt;li&gt;共享网络瓶颈的连接较多时，可能会因为缓冲区被填满而发生丢包。但这种丢包并不意味着发生了拥塞&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结一句话，时代已经变了，丢包不一定等于拥塞了。&lt;/p&gt;

&lt;h3 id=&quot;基于带宽和rtt决定拥塞窗口&quot;&gt;基于带宽和RTT决定拥塞窗口&lt;/h3&gt;

&lt;p&gt;BBR既然不把丢包作为拥塞出现的信号，就需要找到其他机制来检测拥塞是否出现。Vegas算法基于时延来判断是否出现了拥塞，Westwood算法基于带宽和RTT来决定拥塞窗口的大小，但是受限于linux拥塞控制实现的原因，Westwood计算带宽和RTT的方式十分粗糙。BBR也采用了和Westwood一样的方式，但是它的作者同时改进了linux拥塞控制的实现，使得BBR能够得到更完全的控制。&lt;/p&gt;

&lt;p&gt;一个网路链路能够传输的最大吞吐取决于这条网路链路上的物理时延（Round-Trip Propagation Time，在BBR中简写为RTprop）与链路上速度最低的一段的带宽（Bottle-neck Bandwidth，在BBR中简写为BtlBw）的乘积。这个乘积叫做BDP（Bottle-neck Bandwidth Delay Production），即BDP=BltBw x RTprop，也就是将链路填满数据同时不填充中间链路设备缓冲的最大数据量。BBR追求的就是数据发送速率达到BDP这个最优点。&lt;/p&gt;

&lt;h4 id=&quot;带宽与rtt的测不准原理&quot;&gt;带宽与RTT的测不准原理&lt;/h4&gt;

&lt;p&gt;在一条网络链路上，RTprop和BtlBw实际上是互相独立的两个变量，它们都可能在对方不变的情况下增大或者减小。而要精确地测得延时的最小值，就必须保证网络设备的缓冲为空，链路上的流量越少越好，但此时的带宽就低；要测得带宽的最大值，就必须发送尽可能多的数据来把网络带宽填满，缓冲区就会有部分数据，延时就会上升；这就有点类似物理学中的不确定性原理。&lt;/p&gt;

&lt;p&gt;而BBR对于这个问题的解决方式就是取一定时间范围内的RTprop极小值与BtlBw极大值作为估计值。&lt;/p&gt;

&lt;h2 id=&quot;bbr算法的各个阶段&quot;&gt;BBR算法的各个阶段&lt;/h2&gt;

&lt;p&gt;在连接建立的时候，BBR也采用类似慢启动的方式逐步增加发送速率，然后根据收到的ack计算BDP，当发现BDP不再增长时，就进入拥塞避免阶段（这个过程完全不管有没有丢包）。在慢启动的过程中，由于几乎不会填充中间设备的缓冲区，这过程中的延迟的最小值就是最初估计的最小延迟；而慢启动结束时的最大带宽就是最初的估计的最大延迟。&lt;/p&gt;

&lt;p&gt;慢启动结束之后，为了把慢启动过程中可能填充到缓冲区中的数据排空，BBR会进入排空阶段，这期间会降低发送速率，如果缓冲区中有数据，降低发送速率就会使延时下降（缓冲区逐渐被清空），直到延时不再下降。&lt;/p&gt;

&lt;p&gt;排空阶段结束后，进入稳定状态，这个阶段会交替探测带宽和延迟。带宽探测阶段是一个正反馈系统：定期尝试增加发包速率，如果收到确认的速率也增加了，就进一步增加发包速率。具体来说，以每8个RTT为周期，在第一个RTT中，尝试以估计带宽的5/4的速度发送数据，第二个RTT中，为了把前一个RTT多发出来的包排空，以估计带宽的3/4的速度发送数据。剩下6个RTT里，使用估计的带宽发包（估计带宽可能在前面的过程中更新）。 这个机制使得BBR在带宽增加时能够迅速提高发送速率，而在带宽下降时则需要一定的时间才能降低到稳定的水平。&lt;/p&gt;

&lt;p&gt;除了带宽检测，BBR还会进行最小延时的检测。每过10s，如果最小RTT没有改变（也就是没有发现一个更低的延迟），就进入延迟探测阶段。延迟探测阶段持续的时间仅为 200 毫秒（或一个往返延迟，如果后者更大），这段时间里发送窗口固定为4个包，也就是几乎不发包。这段时间内测得的最小延迟作为新的延迟估计。也就是说，大约有2%的时间BBR会用极低的发包速率来测量延迟。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这次主要总结了BBR的特点以及各个阶段，但是BBR并非就是完美的横扫一切的拥塞控制算法，它需要和实际的场景相结合才能发挥威力，后续再继续深入了解了。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">jetty QueuedThreadPool 源码分析</title><link href="http://localhost:4000/2019/12/09/QueuedThreadPool.html" rel="alternate" type="text/html" title="jetty QueuedThreadPool 源码分析" /><published>2019-12-09T00:00:00+08:00</published><updated>2019-12-09T00:00:00+08:00</updated><id>http://localhost:4000/2019/12/09/QueuedThreadPool</id><content type="html" xml:base="http://localhost:4000/2019/12/09/QueuedThreadPool.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;目前手里维护的一个http服务采用的容器是jetty，并且不是spring-boot，连spring都没有，就是手写的jetty server和handler等等。最近在做压测时发现一个奇怪的现象：jetty的线程池在达到满载（最大2000个线程）之后，即使降低了压力，线程池的线程数仍然没有及时的下降到正常水平，而是非常缓慢地下降，大约每两个小时下降1%左右。&lt;/p&gt;

&lt;p&gt;这让我感到很奇怪，明明线程的idle时间设置的是5min，为什么线程数过了很久都没有恢复正常，本以为jetty里的线程池应该和jdk自带的线程池没什么区别，看来事实并不是我想象的那样，于是决定了解下jetty提供的QueuedThreadPool的具体实现（基于9.4.8.v20171121版本）。&lt;/p&gt;

&lt;h2 id=&quot;源码部分&quot;&gt;源码部分&lt;/h2&gt;

&lt;p&gt;我们在项目中使用的是QueuedThreadPool，它继承了AbstractLifeCycle类，同时实现了SizedThreadPool以及Dumpable两个接口。AbstractLifeCycle是jetty中用于管理实例生命周期相关的逻辑，SizedThreadPool则继承自jdk的ThreadPool，在其基础上增加了一些用于获取ThreadPool状态的方法，而Dumpable则声明了将对象dump为string的方法。&lt;/p&gt;

&lt;p&gt;QueuedThreadPool采用了jdk中的ThreadPoolExecutor不同的实现方式，看起来逻辑似乎更简单。&lt;/p&gt;

&lt;h3 id=&quot;成员变量&quot;&gt;成员变量&lt;/h3&gt;

&lt;p&gt;QueuedThreadPool的成员变量并不多，具体列列举如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//线程池中一共有多少线程&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicInteger&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsIdle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池中一共有多少空闲的线程&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AtomicLong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_lastShrink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//上一次“缩小”的时间戳，“缩小”即减少线程数&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池中的线程&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_joinLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//等待所有线程结束用到的lock&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//线程池任务队列&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadGroup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadGroup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池任的线程组&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池名称&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_idleTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程空闲的是时间&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_maxThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池最大size&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_minThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池最下size&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_priority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池中线程的优先级&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_daemon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池中线程的daemon属性&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_detailedDump&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//dump线程池时是否打印详细的信息&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_lowThreadsThreshold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//用于判断线程池是否缺少足够的线程的阈值&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolBudget&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_budget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池任务队列&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//线程池中每个线程的主要运行逻辑&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;主要方法&quot;&gt;主要方法&lt;/h3&gt;

&lt;h4 id=&quot;dostart&quot;&gt;doStart&lt;/h4&gt;

&lt;p&gt;doStart实际上是在AbstractLifeCycle中定义的，表示实例生命周期的开始，QueuedThreadPool中的主要实现就是预先启动_minThreads个线程。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;startThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_minThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;dostop&quot;&gt;doStop&lt;/h4&gt;
&lt;p&gt;doStop也是在AbstractLifeCycle中定义的，表示实例生命周期的结束，QueuedThreadPool中的主要实现就是尝试停止所有线程。在停止过程中，会尝试将所有已提交的任务执行完。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getStopTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jobs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//如果没有指定stopTimeout，直接清空任务队列&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//用noop把队列填满，目前一共有多少个线程就提交多少个noop任务&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{};&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//先用stopTimeout一半的时间来让所有任务自然执行完&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stopby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toNanos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NANOSECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//如果到这里还有任务没执行完，再尝试激进一点的策略&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//把剩余的线程interrupt一遍&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//再用stopTimeout一半的时间来让所有任务自然执行完&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stopby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toNanos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;NANOSECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stopby&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canwait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//如果还有任务没执行完，就把剩下的线程都打印一遍&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;yield&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unstopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dmp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StackTraceElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unstopped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;dmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lineSeparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;\tat &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Couldn't stop {}{}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unstopped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unstopped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{} Couldn't stop {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unstopped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_budget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_budget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_joinLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_joinLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;notifyAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;总的来说，结束过程中会在指定的超时时间过去一半的时候把还没执行完的线程都interrupt一下，如果到最后还有任务没执行完，就把它们dump并打印出来。&lt;/p&gt;

&lt;h4 id=&quot;execute&quot;&gt;execute&lt;/h4&gt;

&lt;p&gt;execute即向线程池提交任务的方法，QueuedThreadPool的实现也很简单，就是尝试把任务放到队列里，然后按需创建新的线程。如果入队列失败，则抛出拒绝异常。这里并不向ThreadPoolExecutor一样支持指定reject发生时的处理侧率，而是直接抛出一个拒绝异常。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;queue {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//尝试将任务放入队列&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{} rejected {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RejectedExecutionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;//如果入队列成果之后发现一个线程都没了，就重新创建一个线程&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;startThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;线程的主要执行逻辑&quot;&gt;线程的主要执行逻辑&lt;/h4&gt;

&lt;p&gt;线程的主要执行逻辑就是runnable成员变量了，其大体的思路就是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程启动后，开始从任务队列中循环获取任务。&lt;/li&gt;
  &lt;li&gt;如果能成功获取任务，就执行获取到的任务。&lt;/li&gt;
  &lt;li&gt;如果无法获取新的任务，则跳出获取任务的循环，将_threadsIdle加一，标识自身进入了idle状态&lt;/li&gt;
  &lt;li&gt;当自身出于idle状态时，根据指定的条件判断是否需要杀掉空闲的线程&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shrink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//是否杀掉自身的标识&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//自身是否属于意外退出的标识&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;从队列中获取任务，不会阻塞&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsIdle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//如果获取到了任务，同时没有空闲线程，就创建一个线程。这里是否有必要？&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//虽然_threadsIdle，但是当前线程不就是空闲的吗？看9.4.24.v20191120版本的实现里已经没有这逻辑了&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;startThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;nl&quot;&gt;loop:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//循环获取任务并执行&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;run {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;runJob&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isDebugEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ran {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;//进入空闲状态&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;_threadsIdle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;incrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;c1&quot;&gt;//如果没有指定idleTimeout，就阻塞地尝试获取任务&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_idleTimeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_jobs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                &lt;span class=&quot;c1&quot;&gt;//判断是否需要结束自己：1. size大于_minThreads 2. 距离上次结束线程超过了_idleTimeout&lt;/span&gt;
                                &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_minThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_lastShrink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                                    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nanoTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toNanos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_idleTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                                    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_lastShrink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareAndSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;compareAndSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                                            &lt;span class=&quot;c1&quot;&gt;//如果满足结束的条件，就跳出外层循环，结束执行&lt;/span&gt;
                                            &lt;span class=&quot;n&quot;&gt;shrink&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                                            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                                &lt;span class=&quot;c1&quot;&gt;//如果不满足结束的条件，就尝试阻塞获取任务，同时超时时间为idleTimeout&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idleJobPoll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_threadsIdle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;decrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;startThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shrink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isRunning&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;LOG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;warn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Unexpected thread death: {} in {}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QueuedThreadPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_threadsStarted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;decrementAndGet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getMaxThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;startThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可以看出QueuedThreadPool比jdk中的ThreadPoolExecutor确实简单的多，而回到最开始的问题，线程池size迟迟不下降的原因就是线程池对idleTimeout的处理方式：当线程出于idle状态时，它就有可能被结束，但只是有可能而不是一定，因为每次结束一个线程都要间隔idleTimeout指定的时间。而我们的项目里指定线程数最大是2000，idleTimeout是5min，就表示每5min才会结束一个线程，所以线程池size下降的速度才会这么慢。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言 目前手里维护的一个http服务采用的容器是jetty，并且不是spring-boot，连spring都没有，就是手写的jetty server和handler等等。最近在做压测时发现一个奇怪的现象：jetty的线程池在达到满载（最大2000个线程）之后，即使降低了压力，线程池的线程数仍然没有及时的下降到正常水平，而是非常缓慢地下降，大约每两个小时下降1%左右。</summary></entry><entry><title type="html">各种TCP拥塞控制算法</title><link href="http://localhost:4000/2019/11/24/TCP-algorithms.html" rel="alternate" type="text/html" title="各种TCP拥塞控制算法" /><published>2019-11-24T00:00:00+08:00</published><updated>2019-11-24T00:00:00+08:00</updated><id>http://localhost:4000/2019/11/24/TCP%20algorithms</id><content type="html" xml:base="http://localhost:4000/2019/11/24/TCP-algorithms.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;自从TCP拥塞控制的概念提出以来，TCP拥塞控制算法经历了一系列的演化。这里根据网上的资料大致总结一下各个TCP拥塞控制算法。&lt;/p&gt;

&lt;h2 id=&quot;tcp-tahoereno&quot;&gt;TCP Tahoe/Reno&lt;/h2&gt;

&lt;p&gt;最初的实现，包括慢启动、拥塞避免两个部分。基于重传超时（retransmission timeout/RTO）和重复确认为条件判断是否发生了丢包。两者的区别在于：Tahoe算法下如果收到三次重复确认，就进入快重传立即重发丢失的数据包，同时将慢启动阈值设置为当前拥塞窗口的一半，将拥塞窗口设置为1MSS，进入慢启动状态；而Reno算法如果收到三次重复确认，就进入快重传，但不进入慢启动状态，而是直接将拥塞窗口减半，进入拥塞控制阶段，这称为“快恢复”。&lt;/p&gt;

&lt;p&gt;而Tahoe和Reno算法在出现RTO时的措施一致，都是将拥塞窗口降为1个MSS，然后进入慢启动阶段。&lt;/p&gt;

&lt;h2 id=&quot;tcp-vegas&quot;&gt;TCP Vegas&lt;/h2&gt;

&lt;p&gt;TCP Vegas算法由 Lawrence Brakmo 和 Larry L. Peterson 在1994年提出，它和其他拥塞控制算法的不同之处在于Vegas算法并不急于丢包来判断是否发生了拥塞，而是通过数据包延迟来判断。Vegas通过RTT（roundtrip time）来决定增加或者减小拥塞窗口，它能够拥塞将要发生时就避免拥塞，而不是等到拥塞已经发生之后再减小发送速度，因此能够减小重传和超时的几率。Vegas算法与其他算法（比如Reno）共存时，会由于比其他算法更先降低发送速率而出现公平性问题。&lt;/p&gt;

&lt;h2 id=&quot;tcp-new-reno&quot;&gt;TCP New Reno&lt;/h2&gt;

&lt;p&gt;TCP New Reno主要改进了TCP Reno中快速恢复阶段的重传。&lt;/p&gt;

&lt;p&gt;在Reno的快恢复中，一旦出现3次重复确认，TCP发送方会重发数据包并设置定时器等待该重发数据包被确认。当重发的数据包被确认后，就立即退出快速恢复阶段，进入拥塞控制阶段。但如果一次拥塞中出现多个丢包，Reno会误以为发生了多次拥塞而重复减小拥塞窗口导致发送速率下降。&lt;/p&gt;

&lt;p&gt;而在New Reno的快速恢复中，一旦出现3次重复确认，会记下出现重复确认时未确认的数据包的最大序列号，然后重发重复确认的数据包。如果有多个数据包丢失，则继续重发丢失的数据包，知道最大序列号的数据包被确认才推出快恢复阶段。&lt;/p&gt;

&lt;p&gt;New Reno在低错误率时运行效率和“选择确认”（Selective ACKnowledgement，SACK）相当，在高错误率仍优于Reno。&lt;/p&gt;

&lt;h2 id=&quot;tcp-biccubic&quot;&gt;TCP BIC/CUBIC&lt;/h2&gt;

&lt;p&gt;TCP BIC（Binary Increase Congestion control）旨在优化高速高延迟网络（即“长肥网络”（long fat network，LFN））的拥塞控制，其拥塞窗口算法使用二分搜索算法尝试找到能长时间保持拥塞窗口最大值的值。Linux内核在2.6.8至2.6.18使用该算法作为默认TCP拥塞算法。&lt;/p&gt;

&lt;p&gt;BIC算法采用二分查找的方式来确定最大的窗口大小：如果发生丢包时窗口大小是W1，那么最大窗口Wmax应该小于W1；这时将窗口缩小到W2（乘以一个系数，也就是乘法减小），那么可以预期W1&amp;gt;Wmax&amp;gt;W2；这时再将窗口大小设置为(W1+W2)2（也就是二分查找），即每收到一个ACK就把窗口大小设置为两个界限的中点。&lt;/p&gt;

&lt;p&gt;如果窗口大小已经无限逼近W1，说明网络状况又变好了（可用带宽增加了），这时BIC会尝试往上寻找更大的Wmax。而在往上寻找时，BIC会镜像的利用逼近当前Wmax的路径去搜寻，也就是前面是如何先快后慢慢地靠近当前Wmax的，后面就反过来先慢后快地增长。&lt;/p&gt;

&lt;p&gt;而CUBIC则是比BIC更温和和系统化的分支版本，其使用三次函数代替二分算法作为其拥塞窗口算法（因为实际上BIC的搜索曲线看起来就像一个三次函数，所以干脆就写一个三次函数来模拟曲线），并且使用函数拐点作为拥塞窗口的设置值。Linux内核在2.6.19后使用该算法作为默认TCP拥塞算法。&lt;/p&gt;

&lt;h2 id=&quot;tcp-westwoodwestwood&quot;&gt;TCP Westwood/Westwood+&lt;/h2&gt;

&lt;p&gt;TCP Westwood改良自New Reno，不同于以往其他拥塞控制算法使用丢失来测量，其通过对确认包测量来确定一个“合适的发送速度”，并以此调整拥塞窗口和慢启动阈值。Westwood改良了慢启动阶段算法为“敏捷探测（Agile Probing）”，并且设计了一种持续探测拥塞窗口的方法来控制进入“敏捷探测”，使连接尽可能地使用更多的带宽。Westwood+使用更长的带宽估计间隔和优化的滤波器来修正Westwood对ACK压缩场景对带宽估计过高的问题。通过以上改良，TCP Westwood系列算法在有线网络和无线网络的拥塞控制上取得平衡，尤其研究中针对于无线通信网络上。&lt;/p&gt;

&lt;h2 id=&quot;compound-tcp&quot;&gt;Compound TCP&lt;/h2&gt;

&lt;p&gt;Compound TCP是微软自己实现的TCP拥塞控制算法，通过同时维护两个拥塞窗口，来实现在长肥网络有较好的性能而又不损失公平性。CTCP维护两个拥塞窗口：一个常规的AIMD（英语：Additive increase/multiplicative decrease）窗口，以及一个基于延迟的窗口，最终实际使用的滑动窗口大小是这两个窗口的和。AIMD窗口与Reno的增加方式相同；如果延迟小，基于延迟的窗口将迅速增加以提高网络的利用率。一旦经历了排队，延迟窗口将逐渐减小以补偿增加的AIMD窗口。这样的目的是保持两者的总和大致恒定，使算法估计带宽时延积的路径。&lt;/p&gt;

&lt;h2 id=&quot;tcp-prr&quot;&gt;TCP PRR&lt;/h2&gt;
&lt;p&gt;TCP PRR（TCP Proportional Rate Reduction ）是旨在恢复期间提高发送数据的准确性。该算法确保恢复后的拥塞窗口大小尽可能接近慢启动阈值&lt;/p&gt;

&lt;h2 id=&quot;tcp-bbr&quot;&gt;TCP BBR&lt;/h2&gt;
&lt;p&gt;TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来建立网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可以看出，TCP拥塞控制主要是：1、探测是否出现拥塞；2、出现拥塞时如何反应。&lt;/p&gt;

&lt;p&gt;最初的算法是基于丢包来判断是否发生了拥塞，一旦出现拥塞之后就降低发送速率来避免拥塞。后面有出现了基于RTT判断拥塞的算法，但是这种算法会因为太“君子”而提前减小发送速率（让出带宽），从而可能被共存的其他算法进一步压榨产生公平性问题。微软的CTCP通过维护两个窗口来避免这种公平性问题，一个AIMD的窗口来保证不被其他人压榨，另一个基于延迟的窗口能够保证有带宽时能迅速提高来提高带宽利用率。而BBR则直接采用主动探测的方式来判断拥塞是否发生。&lt;/p&gt;

&lt;p&gt;当出现拥塞之后，通常需要降低发送速率来避免拥塞进一步加剧，而不同算法在这时的处理都不尽相同，最初的算法通过直接降低发送速率到1来简单处理，但是这种方式太过粗暴，后续的其他算法也都做了不同的尝试。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">jvm safepoint</title><link href="http://localhost:4000/2019/11/17/safepoint.html" rel="alternate" type="text/html" title="jvm safepoint" /><published>2019-11-17T00:00:00+08:00</published><updated>2019-11-17T00:00:00+08:00</updated><id>http://localhost:4000/2019/11/17/safepoint</id><content type="html" xml:base="http://localhost:4000/2019/11/17/safepoint.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;多线程编程是一件很难的事，或者说编写在多线程条件下运行良好的代码很难。java提供了synchronized和volatile关键字，还有Lock类和Atomic相关的类来帮助我们正确的实现并发逻辑，但我在实际工作中仍倾向于尽量避免并发，还有一个偷懒的做法就是需要并发访问的变量总是加上volatile修饰。&lt;/p&gt;

&lt;p&gt;最近遇到了两个并发相关的例子，一个是某个同事编写的利用AtomicInteger类实现的lock-free逻辑出现了bug，由于边界条件没处理好，导致出现死循环的情况；另一个是某个服务由于平时负载比较高，出现了偏向锁撤销耗时过长的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;偏向锁撤销&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;偏向锁实际上是jvm对锁的一种优化，它假定对于一个锁，实际上只有一个线程在尝试访问。偏向锁的实现很简单，就是在一个线程访问锁时，将这个锁的持有者直接标记为这个线程，当这个线程再尝试获取锁时，只需要检查这个持有者标记即可。偏向锁的优化在实际并没有多线程竞争的场景下能够有效提高程序的性能，但是当“没有多线程竞争”这个假设不成立，偏向锁就需要额外的逻辑进行撤销，而这个撤销就有可能会带来较长时间的停顿，影响程序的性能。&lt;/p&gt;

&lt;p&gt;为什么说偏向锁撤销可能会导致长时间停顿呢，是因为偏向锁的撤销实际上需要在安全点时进行。偏向锁撤销的需要暂停拥有锁的线程并操作它的栈，所以需要在安全点进行。而程序进入安全点所需的时间是不确定的，具体的原因就跟安全点的具体实现有关。&lt;/p&gt;

&lt;h2 id=&quot;safepoint&quot;&gt;safepoint&lt;/h2&gt;

&lt;p&gt;安全点（以下称safepoint）是jvm中的一个重要的概念，jvm中很多场景都会遇到它，最常见的应该是GC（虽然我前面提到的是偏向锁撤销）。safepoint的含义表示的时程序中的某些固定位置，在这些位置上程序的状态是“确定”的，这时jvm就可以根据程序的状态进行一些特殊的操作，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;gc：gc时需要将不再存活的对象清理掉，所以需要“确定”地知道哪些对象不再存活。gc时还需要扫描每个线程的栈，所以需要“确定”的直到栈中的每个对象的类型（引用还是值）。&lt;/li&gt;
  &lt;li&gt;偏向锁撤销：这个前面提到了，因为需要暂停线程，同时操作线程的栈。&lt;/li&gt;
  &lt;li&gt;更新OopMap：oop（ordinary object pointer）是hotspot虚拟机里用于记录对象的元数据的数据结构，它记录了对象内各个偏移量对应的数据的类型。OopMap主要用于实现准确式GC，关于准确式GC的介绍可以参考&lt;a href=&quot;https://www.wikiwand.com/en/Tracing_garbage_collection#/Precise_vs._conservative_and_internal_pointers&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Code deoptimization/Flushing code cache/Class redefinition/Various debug operation：来自&lt;a href=&quot;http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;safepoint的位置&quot;&gt;safepoint的位置&lt;/h3&gt;

&lt;p&gt;在jvm的运行时管理中，利用safepoint来将整个程序挂起（Stop the World），然后进行一些特殊的操作。而safepoint的思路也很简单：当我们需要执行一些特殊操作（比如gc）时，我们就在程序的某些位置设置一些暂停点，当线程来到这些暂停点时，就将自己挂起。等所有线程都挂起后，我们再进行原定的特殊操作。而safepoint的具体位置通常有以下几个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个字节码命令之后（解释模式）&lt;/li&gt;
  &lt;li&gt;所有的方法返回之前（JIT模式）&lt;/li&gt;
  &lt;li&gt;所有的非计数循环的末尾 （JIT模式）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只在非计数循环的末尾设置safepoint带来了一个问题：假如程序里有一个非常大的计数循环（比如循环100w次），就可能导致safepoint挂起整个程序的时间变长，因为其他已经挂起的线程都需要等待这个大循环执行结束。&lt;/p&gt;

&lt;p&gt;前面提到safepoint的设置会使所有线程挂起，那么具体的gc或者偏向锁撤销又是由谁来执行的呢，答案就是VM线程。在jstack的输出结果中就可以看到有一个叫做”VMThread”的线程，这个线程就是专门负责在STW的时候处理各种特殊操作。&lt;/p&gt;

&lt;h3 id=&quot;safe-region&quot;&gt;safe region&lt;/h3&gt;

&lt;p&gt;safepoint可以让运行中的线程主动挂起，而其他状态下的线程（比如正在sleep或者正阻塞在一个锁上）则无法主动运行到safepoint。对于这种情况jvm中设置了安全区（safe region）的概念，当线程出于某些状态时，jvm认为这种情况下这个线程不会对jvm heap做出任何修改，因此不会破坏jvm的“确定”的状态，所以这些线程可以认为是安全的（处于安全区）。当处于安全区的线程要从安全区出来的时候，同样需要检查是否应该主动挂起。jvm中设定以下几种状态的线程就是处于safe region：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处于阻塞或者等待中&lt;/li&gt;
  &lt;li&gt;正在执行JNI方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以当线程处于以上几个状态时，我们就认为它们就和达到safepoint一样，可以执行特殊的操作了。为了防止线程从safe region返回后对jvm heap进行更改，当STW时线程在从safe region返回时都会主动挂起。&lt;/p&gt;

&lt;h3 id=&quot;线程挂起的实现&quot;&gt;线程挂起的实现&lt;/h3&gt;

&lt;p&gt;通过在特定的位置设置safepoint，我们可以让程序在需要的时候挂起。当需要STW的时候，safepoint会被激活，每个线程在运行到safepoint时，都会主动检查safepoint的状态，如果safepoint被激活，线程就会进入挂起状态。简单来说，&lt;strong&gt;线程在检查safepoint时会主动访问一个特定的内存页，而当STW时这个内存页设置为不可读，所以每个尝试读这个内存页的线程也就会挂起&lt;/strong&gt;。而这个检查过程是通过JIT编译器主动插入到指令中的。&lt;/p&gt;

&lt;p&gt;而具体来说，线程处于不同状态时，挂起线程的方式也有不同：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当线程处于解释执行时，解释器会强制将下一个指令指向检查safepoint的指令&lt;/li&gt;
  &lt;li&gt;当线程正在执行JNI方法时，VMThread不会等待其返回，而是认为其处于safe region。当它返回时会阻塞直到STW结束&lt;/li&gt;
  &lt;li&gt;当线程正在执行已经编译好的方法时，编译好的代码里会携带检查safepoint的逻辑，我们将特定的内存页设置为不可读即可&lt;/li&gt;
  &lt;li&gt;当线程正在阻塞时，VMThread不会等待其返回，而是认为其处于safe region。当它返回时会阻塞直到STW结束&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当线程尝试访问标记为不可读的内存页时，会触发SIGSEGV信号，从而触发jvm内的signal handler，signal handler在收到SIGSEGV信号时会确认是否是由于safepoint检查触发了这个信号，如果是就会将自身挂起。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;大部分内容参考了&lt;a href=&quot;https://blog.csdn.net/ITer_ZC/category_9263360.html&quot;&gt;iter_zc的博客&lt;/a&gt;，在此表示感谢。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">TCP拥塞控制</title><link href="http://localhost:4000/2019/10/27/TCP-congestion.html" rel="alternate" type="text/html" title="TCP拥塞控制" /><published>2019-10-27T00:00:00+08:00</published><updated>2019-10-27T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/27/TCP%20congestion</id><content type="html" xml:base="http://localhost:4000/2019/10/27/TCP-congestion.html">&lt;h2 id=&quot;tcp拥塞控制的起源&quot;&gt;TCP拥塞控制的起源&lt;/h2&gt;

&lt;p&gt;1986年，从LBL到UC Berkeley的网络吞吐因为拥塞出现了从32Kbps到40bps的急剧下降，Van Jacobson 在1988年的论文《Congestion Avoidance and Control》从这个问题出发，提出了数据包守恒定律以及慢启动、拥塞控制和快重传的算法，在1990年又提出了快恢复算法。&lt;/p&gt;

&lt;h2 id=&quot;数据包守恒原则&quot;&gt;数据包守恒原则&lt;/h2&gt;

&lt;p&gt;在一个运行平稳的TCP连接中流动的数据包应该是守恒的，意思是当只有旧的数据包被成功传输到对端后，新的数据包才能加入到连接中。在TCP协议中，我们可以使用ack来作为判断数据包是否已经成功到达对端的依据，就是说当发送端收到good ack（大于发送端当前已经收到的最大ack的ack）时，它就可以发送新的数据包了。这种根据ack来决定继续发送数据包的机制就叫做self clocking（也叫做ack clocking）。&lt;/p&gt;

&lt;h2 id=&quot;慢启动&quot;&gt;慢启动&lt;/h2&gt;

&lt;p&gt;通过数据包守恒原则，我们知道可以通过ack来决定是否发送新的数据，而要收到ack就要先发送数据。慢启动就开始发送数据时的行为控制。慢启动的总体思路就是从一个很低的初始值开始，逐渐增加数据发送的速度，直到达到超时或者丢包为止。慢启动的实现思路如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个连接维护一个变量cwnd（congestion window）&lt;/li&gt;
  &lt;li&gt;当连接刚建立或者遇到丢包时，将cwnd设置为1，单位为MSS（maximum segment size）&lt;/li&gt;
  &lt;li&gt;每收到一个新的ack，cwnd加一&lt;/li&gt;
  &lt;li&gt;当发送数据时，能够发送的数据包数量为min(cwnd,awnd)，awnd为接收端的滑动窗口大小(reciver’s advertised window)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以预见，在没有出现超时或者丢包时，慢启动增长的速度是指数级的，所以慢启动实际上并没有那么“慢”，“慢”是慢在它的起点只有1个MSS。&lt;/p&gt;

&lt;h2 id=&quot;拥塞避免&quot;&gt;拥塞避免&lt;/h2&gt;

&lt;p&gt;前面提到，慢启动的目的是逐渐增加发送速度进行试探，直到出现网络拥塞，而真正出现拥塞时又该怎么做呢，就是“拥塞避免”所做的事情了。拥塞避免主要由两部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个判断当前网路出现拥塞的机制&lt;/li&gt;
  &lt;li&gt;在出现拥塞时降低发送速度的机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而拥塞避免的实现思路如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当出现超时时，将cwnd设置为当前值的一半（即当出现超时时就认为是出现了拥塞）&lt;/li&gt;
  &lt;li&gt;每收到一个新的ack，cwnd加1/cwnd（即当传输成功cwnd个数据包时，窗口大小加一，也就是随着RTT线性增加）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的两个变更cwnd的行为通常称为“乘法减小”和“加法增大”。&lt;/p&gt;

&lt;h2 id=&quot;结合慢启动和拥塞避免的算法&quot;&gt;结合慢启动和拥塞避免的算法&lt;/h2&gt;

&lt;p&gt;值得注意的是，慢启动和拥塞避免实际上是两个不同的算法，它们一个用于试探网络资源的上限，另一个用于资源使用率达到或者接近上限时的行为。在1988年的论文中给出了一个结合了慢启动和拥塞避免的算法，具体实现思路如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送端维持两个变量：拥塞窗口cwnd（congestion window）和慢启动门限ssthresh（slow start threshold），通过这两个变量来决定当前应该执行慢启动还是拥塞避免算法。&lt;/li&gt;
  &lt;li&gt;发送数据时，能够发送的数据包数量为min(cwnd,awnd)&lt;/li&gt;
  &lt;li&gt;出现超时时，ssthresh更新为cwnd/2（但不能小于2），cwnd设置为1&lt;/li&gt;
  &lt;li&gt;每收到一个新的zck，发送端的行为是:
    &lt;ul&gt;
      &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;cwnd&amp;lt;ssthresh&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;cwnd+=1&lt;/code&gt;（慢启动阶段，窗口指数级别增加）&lt;/li&gt;
      &lt;li&gt;否则&lt;code class=&quot;highlighter-rouge&quot;&gt;cwnd+=1/cwdn&lt;/code&gt;（拥塞避免阶段，窗口线性增加）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;快重传&quot;&gt;快重传&lt;/h2&gt;

&lt;p&gt;快速重传的目的就是让发送端尽快感知到丢包。TCP发送方在每发送一个分段时会启动一个计时器，如果相应的数据包确认没在特定时间内被送回，发送方就假设这个分段在网络上丢失了，需要重发。这也是TCP用来估计RTT的测量方法。&lt;/p&gt;

&lt;h3 id=&quot;重复确认&quot;&gt;重复确认&lt;/h3&gt;

&lt;p&gt;重复确认基于以下过程：如果接收方接收到一个数据分段，就会将该分段的序列号加上数据字节长的值，作为分段确认的确认号，发送回发送方，表示期望发送方发送下一个序列号的分段。但是如果接收方提前收到更大的序列号的分段，或者说接收到无序到达的分段，接收方需要&lt;strong&gt;立即&lt;/strong&gt;使用之前的确认号发送分段确认。此时如果发送方收到接收方相同确认号的分段确认超过1次，并且该对应序列号的分段超时计时器仍没超时的话，则这就是出现重复确认，需要进入快速重传。&lt;/p&gt;

&lt;p&gt;快送重传就是基于以下机制：如果假设重复阈值为3，当发送方收到4次相同确认号的分段确认（第1次收到确认期望序列号，加3次重复的期望序列号确认）时，则可以认为继续发送更高序列号的分段将会被接受方丢弃，而且会无法有序送达。发送方应该忽略超时计时器的等待重发，立即重发重复分段确认中确认号对应序列号的分段。&lt;/p&gt;

&lt;h2 id=&quot;tcp拥塞控制的各个实现&quot;&gt;TCP拥塞控制的各个实现&lt;/h2&gt;

&lt;p&gt;这里先列举各个TCP拥塞控制的实现，具体接受后续再补上了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP Tahoe/Reno&lt;/li&gt;
  &lt;li&gt;TCP Vegas&lt;/li&gt;
  &lt;li&gt;TCP New Reno&lt;/li&gt;
  &lt;li&gt;TCP BIC/CUBIC&lt;/li&gt;
  &lt;li&gt;TCP Westwood/Westwood+&lt;/li&gt;
  &lt;li&gt;Compound TCP&lt;/li&gt;
  &lt;li&gt;TCP PRR&lt;/li&gt;
  &lt;li&gt;TCP BBR&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">TCP拥塞控制的起源</summary></entry><entry><title type="html">java内存模型与volatile</title><link href="http://localhost:4000/2019/10/20/volatile.html" rel="alternate" type="text/html" title="java内存模型与volatile" /><published>2019-10-20T00:00:00+08:00</published><updated>2019-10-20T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/20/volatile</id><content type="html" xml:base="http://localhost:4000/2019/10/20/volatile.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在计算机硬件结构中，为了平衡cpu和内存之间由于速度带来的差距，cpu中引入了cache作为处理器与内存之间的缓冲。在多核的处理器中，每个核都有属于自己的cache，这就带来了cache一致性的问题。前面提到的MESI协议就是用于处理cache一致性问题的一个协议，它将cache的内容分成几个状态，并要求每个核监听总线上传来的其他核发出的事件，根据这些外部事件以及自身操作cache的内部事件来维护cache的内容和状态，以达到cache一致性。但MESI协议中特定的优化有时会导致cache中存在临时的不一致的数据，所以引入了内存屏障来规避这个问题。&lt;/p&gt;

&lt;p&gt;即使有cache的存在，当处理器等待cache的载入时仍然会浪费时间。所以处理器会在当前指令因等待数据阻塞时尝试执行其他不依赖这个数据的指令，来尽可能提高处理速度，这称为乱序执行。处理器会保证乱序执行的结果与顺序执行的结果一致，但仅在当前处理器范围内。如果有其他任务的计算依赖当前任务的中间结果，就有可能出现不符合预期的结果，这个问题同样可以通过内存屏障来规避。&lt;/p&gt;

&lt;h2 id=&quot;java的内存模型&quot;&gt;java的内存模型&lt;/h2&gt;

&lt;p&gt;java虚拟机规范中定义了java自身的内存模型，通过这个内存模型来屏蔽不同的操作系统和硬件带来的差异，达到各个平台运行效果一致的目标。java内存模型规定所有的变量都存储在主内存中，每个线程有自己的工作内存，线程在访问变量时都直接从工作内存中访问，而不能访问主内存。一个线程不能访问其他的线程的工作内存，线程之间的变量传递都需要经过主内存来完成。这里的线程、工作内存和主内存有有点类似计算机硬件结构中的处理器、cache和内存的关系。此外，java虚拟机中的即时编译中也有类似指令重排序的优化。java内存模型的介绍比较多，这里就不详细展开了。&lt;/p&gt;

&lt;h2 id=&quot;volatile变量&quot;&gt;volatile变量&lt;/h2&gt;

&lt;p&gt;在java中有一个用于实现单例模式的方式，叫做“双成例检查”。双成例检查利用了synchronized和volatile关键词保证了在并发执行的情况下单例模式的正确性。但是在jdk1.5以前（不包括1.5）的版本是存在问题的，其中具体的原因就是volatile关键词底层实现在jdk1.5才完全正确。&lt;/p&gt;

&lt;p&gt;根据volatile的特性，如果一个变量被标记为volatile，那么它将获得两个额外的属性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在一个线程中对于volatile变量的修改会立即被其他线程感知到，也就是可见性。前面提到，在java内存模型中，各个线程之间的变量传递都需要先经过主内存，所以为了性能考虑，线程不会总是从主内存获取最新的变量的值，而是在特定的时机才从主内存同步最新的内容。而volatile关键词则能够强制触发其他线程同步主内存的内容。&lt;/li&gt;
  &lt;li&gt;禁止指令重排序。对于一个普通的变量，只会保证所有依赖这个变量的地方都能获得正确的结果，而并不会保证对这个变量赋值的顺序和实际的代码执行顺序一致，比如不依赖这个变量的代码可能会被挪到之前或者之后执行，也就是“看起来就像是顺序执行一样”。而volatile关键词能够禁止指令重排序。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在jdk1.5之前的版本，volatile并没有禁止指令重排序的作用，所以即使把变量声明为volatile也会存在volatile变量前后的代码重排序的情况，这也是在jdk1.5之前不能使用双成例检查来实现单例的原因。&lt;/p&gt;

&lt;h2 id=&quot;volatile的实现&quot;&gt;volatile的实现&lt;/h2&gt;

&lt;p&gt;前面提到内存屏障能够避免cache中存在过期数据以及避免乱序执行，而volatile自身也是通过内存屏障来实现上述的2个特性的。&lt;/p&gt;

&lt;p&gt;内存屏障通常分为几个级别：读写（保证屏障前的读写操作都早于屏障后的读写操作）、读（只保证读操作）以及写（只保证写操作）。不同体系结构的硬件对内存屏障的实现都不一样，比如在x86中内存屏障的指令是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;lfence 读操作屏障&lt;/li&gt;
  &lt;li&gt;sfence 写操作屏障&lt;/li&gt;
  &lt;li&gt;mfence 读写操作屏障&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而当我们把实际的java字节码反汇编成汇编指令时，可以看到并没有这几个屏障，而是在写入volatile变量之后添加一条&lt;code class=&quot;highlighter-rouge&quot;&gt;lock addl $0, 0 (%esp)&lt;/code&gt;指令。lock指令的作用是可以使当前处理器的cache内容被写入内存，同时使其他处理器的cache失效，这种操作相当于将本线程的工作内存的内容同步到主内存，也就保证了可见性。而在指令重排序的角度，由于lock指令之前的操作的结果都同步到了内存，也就相当于lock之前的操作都已经完成，这样就相当于“屏障后边的操作无法穿越到屏障前面”的效果。&lt;/p&gt;

&lt;h3 id=&quot;lock实际的作用&quot;&gt;lock实际的作用&lt;/h3&gt;

&lt;p&gt;可以看到，lock实际上具备了内存屏障的语义，那lock具体的作用是什么呢。lock是一个指令前缀，在它后面的指令会保证原子执行。其实现方式就是在指令执行期间设置处理器的&lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK#&lt;/code&gt;信号，这样就能确保处理器能够互斥的操作内存（通过锁定总线来实现），当指令执行完毕之后&lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK#信号&lt;/code&gt;会自动取消。从intel奔腾Pro处理器开始，当要锁定的内存地址已经被加载到cache时，会直接锁定对应的cache而不是设置&lt;code class=&quot;highlighter-rouge&quot;&gt;LOCK#信号&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;也就是说，volatile的实现中通过lock前缀+一条空的指令来锁定cache，实现了可见性和禁止重排序的功能。至于为什么要用&lt;code class=&quot;highlighter-rouge&quot;&gt;addl $0, 0 (%esp)&lt;/code&gt;配合lock前缀是因为lock前缀只支持内存操作类的指令，所以不能直接用lock前缀加空指令nop。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">cache一致性里的MESI协议</title><link href="http://localhost:4000/2019/10/13/MESI.html" rel="alternate" type="text/html" title="cache一致性里的MESI协议" /><published>2019-10-13T00:00:00+08:00</published><updated>2019-10-13T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/13/MESI</id><content type="html" xml:base="http://localhost:4000/2019/10/13/MESI.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在有多个核的处理器的处理器中，每个核都有自己的cache，而如何确保多个核的cache内容的一致则是一个很容易遇到的问题，MESI协议就是一个专门用来解决cache一致性的协议。很多处理器使用的都是MESI协议或者MESI协议的变体，而MESI协议其实也是MSI协议的变种。MESI协议采用了回写（write-back）的策略来更新cache，使得其性能进一步提高，但也带来了额外的风险，回写带来的问题可以在编写程序时使用内存屏障来规避。&lt;/p&gt;

&lt;h2 id=&quot;mesi协议简介&quot;&gt;MESI协议简介&lt;/h2&gt;

&lt;p&gt;MESI协议名字的由来是由其描述的四个cache状态组成的，分别是M(modified)、E(exclusive)、S(shared)和I(invalid)。各个状态的描述具体如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Modified&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据已被修改而且与内存中的数据不一致，数据只在当前cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Exclusive&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据与内存中的数据一致，数据只在当前cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Shared&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据与内存中的数据一致，数据在多个cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Invalid&lt;/td&gt;
      &lt;td&gt;当前cache无效&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;状态转移&quot;&gt;状态转移&lt;/h3&gt;

&lt;p&gt;MESI协议其实是一个状态机，cache的状态会跟根据外部事件的刺激而发生转移，具体的事件分为两类：处理器对cache的请求和总线对cache的请求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PrRd: 处理器请求读一个缓存块&lt;/li&gt;
  &lt;li&gt;PrWr: 处理器请求写一个缓存块&lt;/li&gt;
  &lt;li&gt;BusRd: 窥探器请求指出其他处理器请求读一个缓存块&lt;/li&gt;
  &lt;li&gt;BusRdX: 窥探器请求指出其他处理器请求写一个该处理器不拥有的缓存块&lt;/li&gt;
  &lt;li&gt;BusUpgr: 窥探器请求指出其他处理器请求写一个该处理器拥有的缓存块&lt;/li&gt;
  &lt;li&gt;Flush: 窥探器请求指出请求回写整个缓存到主存&lt;/li&gt;
  &lt;li&gt;FlushOpt: 窥探器请求指出整个缓存块被发到总线以发送给另外一个处理器（缓存到缓存的复制）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而状态之间的转换如下图：
&lt;img src=&quot;/img/Diagrama_MESI.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
   &lt;caption&gt;处理器操作带来的状态转化&lt;/caption&gt;
   &lt;thead&gt;
      &lt;tr&gt;
         &lt;th&gt;初始状态&lt;/th&gt;
         &lt;th&gt;操作&lt;/th&gt;
         &lt;th&gt;响应&lt;/th&gt;
      &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Invalid(I)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;给总线发BusRd信号&lt;/li&gt;
               &lt;li&gt;其他处理器看到BusRd，检查自己是否有有效的数据副本，通知发出请求的缓存&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本，状态转换为(S)&lt;b&gt;Shared&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存都没有有效的副本，状态转换为(E)&lt;b&gt;Exclusive&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 其中一个缓存发出数据；否则从主存获得数据&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;给总线发BusRdX信号&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 其中一个缓存发出数据；否则从主存获得数据&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 见到BusRdX信号后无效其副本&lt;/li&gt;
               &lt;li&gt;向缓存块中写入修改后的值&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Exclusive(E)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;向缓存块中写入修改后的值&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Shared(S)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;发出总线事务BusUpgr信号&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;其他缓存看到BusUpgr总线信号，标记其副本为(I)Invalid.&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Modified(M)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;写操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;tfoot&gt;&lt;/tfoot&gt;
&lt;/table&gt;

&lt;table&gt;
   &lt;caption&gt;不同总线操作带来的状态转化&lt;/caption&gt;
   &lt;thead&gt;
      &lt;tr&gt;
         &lt;th&gt;初始状态&lt;/th&gt;
         &lt;th&gt;操作&lt;/th&gt;
         &lt;th&gt;响应&lt;/th&gt;
      &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Invalid(I)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态保持不变，信号忽略&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX/BusUpgr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态保持不变，信号忽略&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Exclusive(E)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Shared(S)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Modified(M)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;tfoot&gt;&lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;内存屏障的引入&quot;&gt;内存屏障的引入&lt;/h3&gt;

&lt;p&gt;MESI的设计比较简单直接，但是其中有两个地方会导致性能下降：一是更新invalidate状态的cache时，需要尝试从其他cpu甚至是内存获取最新的数据；二是使一个cache变为invalidate时需要等待其他cpu的确认；这两个操作都是比较耗时的，如果cpu在这两个过程中一直等待的话，就会形成浪费。&lt;/p&gt;

&lt;h3 id=&quot;store-buffer&quot;&gt;store buffer&lt;/h3&gt;

&lt;p&gt;为了降低写入invalidate状态的cache的延时，可以引入store buffer。既然写入操作无论如何一定会发生，那么cpu就先发出信号通知其他cpu这个cache已经失效，然后再将本次的写操作更新到store buffer中，等到其他cpu都确认收到信号后再将结果写到内存中。&lt;/p&gt;

&lt;p&gt;这样就避免了更新cache时阻塞等待其他cpu确认的耗时，但是也会导致cpu的更新并没有及时写入cache，所以当cpu需要读取cache时，它需要先确认store buffer中是否有所需的数据，这个机制成为store forwarding。值得注意的是，当cpu在读写自己的store buffer时，对应的数据变更其他cpu是感知不到的。&lt;/p&gt;

&lt;h3 id=&quot;invalidate-queue&quot;&gt;invalidate queue&lt;/h3&gt;

&lt;p&gt;当cpu收到使某个cache失效的消息时，预期的行为是cpu马上执行这个失效操作。但实际上cpu并不会马上执行失效操作，而是先发送确认收到的消息，然后将失效操作加入到invalidate queue中，queue中的操作随后会在适当的时刻执行（并不一定是马上）。之所以需要invalidate queue同样是因为invalidate操作开销比较大，cpu为了执行invalidate操作必须丢弃cache，导致cache命中率下降。这样的好处是能够提高cpu的性能，但同时也导致cache中可能存在过期的数据。&lt;/p&gt;

&lt;h3 id=&quot;内存屏障&quot;&gt;内存屏障&lt;/h3&gt;

&lt;p&gt;针对store buffer和invalidate queue这两个优化带来的问题，我们又提供了内存屏障作为解决方案。内存屏障交给了编写程序的人的手里，利用它就可以规避上面提到的问题。&lt;/p&gt;

&lt;p&gt;内存屏障分为写屏障和读屏障，编写程序时可以在期望的地方加入内存屏障。写屏障会强制cpu清空store buffer的内容，也就是将所有的变更都写入cache，随后变更也就写入了内存，使其对其他cpu可见；读屏障会强制cpu执行invalidate queue中的所有invalidate操作，使自身的cache内容失效，从而使cpu从内存或者其他cpu中获取最新的cache数据。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;MESI协议乍一看和java里的内存模型以及volatile关键字有些相似，后续再详细展开了。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">linux perf</title><link href="http://localhost:4000/2019/09/22/Linux-perf.html" rel="alternate" type="text/html" title="linux perf" /><published>2019-09-22T00:00:00+08:00</published><updated>2019-09-22T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/22/Linux%20perf</id><content type="html" xml:base="http://localhost:4000/2019/09/22/Linux-perf.html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;perf是linux系统中提供的性能分析工具，它基于一个叫“Performance counters”的内核子系统实现，同时支持硬件（CPU、PMU(Performance Monitoring Unit)）和软件(软件计数器、tracepoint)层面的性能分析。&lt;/p&gt;

&lt;h3 id=&quot;perf中的事件&quot;&gt;perf中的事件&lt;/h3&gt;

&lt;p&gt;perf与其他性能调优工具一样，都是通过对监测对象进行采样，根据采样点的分布来推断整个程序的行为。通过perf list命令我们可以看到perf支持很多的采样事件，比如branch-misses、cpu-clock等等。perf中预定义的事件属于不同的类型，比如硬件产生的事件（cache 命中/分支miss）和软件产生的事件（context switch/page fault)等等。&lt;/p&gt;

&lt;h3 id=&quot;tracepoint&quot;&gt;tracepoint&lt;/h3&gt;

&lt;p&gt;tracepoint是linux内核中定义的一些hook，如果被开启，它们就会在执行到特定逻辑时被触发，方便其他工具获取系统内部的运行状态等信息，perf就是利用了tracepoint，它会记录和统计tracepoint的各个事件，生成分析报告。&lt;/p&gt;

&lt;h2 id=&quot;使用方式&quot;&gt;使用方式&lt;/h2&gt;

&lt;p&gt;perf 工具的具体使用方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;perf [--version] [--help] COMMAND [ARGS]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的COMMAND列表可以通过执行perf –help查看，下面列举几个常用的command。&lt;/p&gt;

&lt;h3 id=&quot;perf-stat&quot;&gt;perf stat&lt;/h3&gt;

&lt;p&gt;perf stat的作用是执行一个命令并收集其运行过程中的各个数据，它可以提供一个程序运行情况的总体概览。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user@localhost:~$ perf stat hostname
localhost

 Performance counter stats for 'hostname':

          0.313464      task-clock (msec)         #    0.481 CPUs utilized          
                 2      context-switches          #    0.006 M/sec                  
                 0      cpu-migrations            #    0.000 K/sec                  
               153      page-faults               #    0.488 M/sec                  
           896,723      cycles                    #    2.861 GHz                    
           620,709      instructions              #    0.69  insn per cycle         
           121,143      branches                  #  386.465 M/sec                  
             6,247      branch-misses             #    5.16% of all branches        

       0.000651441 seconds time elapsed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个例子，通过perf stat运行了hostname命令，并将其运行过程中的一些指标汇总显示了出来，比如task-clock、context-switches等待。默认情况下，perf stat 会输出几个常用的事件的统计，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task-clock-msecs：cpu 使用率&lt;/li&gt;
  &lt;li&gt;context-switches：进程切换次数&lt;/li&gt;
  &lt;li&gt;page-faults：发生缺页的次数&lt;/li&gt;
  &lt;li&gt;cpu-migrations：表示进程运行过程中发生了多少次CPU迁移，即被调度器从一个CPU转移到另外一个CPU上运行&lt;/li&gt;
  &lt;li&gt;cycles：处理器时钟，一条机器指令可能需要多个cycles&lt;/li&gt;
  &lt;li&gt;instructions: 机器指令数目&lt;/li&gt;
  &lt;li&gt;branches：遇到的分支指令数&lt;/li&gt;
  &lt;li&gt;branch-misses是预测错误的分支指令数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，我们可以使用-e参数来指定我们感兴趣的事件，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user@localhost:~$ perf stat -e cache-misses hostname
localhost

 Performance counter stats for 'hostname':

          682      cache-misses                                                

       0.000646676 seconds time elapsed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;perf-top&quot;&gt;perf top&lt;/h3&gt;

&lt;p&gt;perf top的作用是实时地显示系统当前的性能统计信息。前面的perf stat用于对一个特定的程序进行分析，而某些时候我们可能并不知道是哪个程序影响了系统性能，这时候就可以用perf top来查找可疑的程序。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Samples: 775  of event 'cpu-clock', Event count (approx.): 92931021
Overhead  Shared Object       Symbol
   8.93%  [kernel]            [k] vsnprintf
   7.73%  perf                [.] rb_next
   5.92%  [kernel]            [k] kallsyms_expand_symbol.clone.0
   5.07%  [kernel]            [k] format_decode
   4.59%  [kernel]            [k] number
   3.40%  perf                [.] symbols__insert
   3.03%  libslang.so.2.2.1   [.] SLtt_smart_puts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的例子显示perf统计了cpu-clock事件的数据，根据比例进行了排序。和perf stat一样，我们可以通过-e参数指定统计其他的事件，比如perf top -e context-switches可以查看进程切换最多的top N个进程。&lt;/p&gt;

&lt;h3 id=&quot;perf-record--perf-report&quot;&gt;perf record &amp;amp; perf report&lt;/h3&gt;

&lt;p&gt;perf record的作用和perf stat类似，它可以运行一个命令并生成统计信息，不过perf record不会将结果显示出来，而是将结果输出到文件中。perf record生成的文件可以用perf report来进行解析。&lt;/p&gt;

&lt;p&gt;perf record还可以通过-g参数，在分析时生成calling graph，帮助定位更上层的逻辑分布。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;通过例子我们可以发现，perf的分析结果中的Symbol一列显示的都是c语言函数的名字。对于java来说，jit编译产生的函数就会直接显示在symbol里，而不是java的函数名，这时要定位问题就不是那么容易了，我们需要通过额外的手段将symbol和java程序的符号表对应起来，具体后续再讨论了。&lt;/p&gt;</content><author><name></name></author><summary type="html">简介</summary></entry><entry><title type="html">Lettuce学习笔记</title><link href="http://localhost:4000/2019/09/08/Lettuce.html" rel="alternate" type="text/html" title="Lettuce学习笔记" /><published>2019-09-08T00:00:00+08:00</published><updated>2019-09-08T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/08/Lettuce</id><content type="html" xml:base="http://localhost:4000/2019/09/08/Lettuce.html">&lt;h2 id=&quot;lettuce简介&quot;&gt;Lettuce简介&lt;/h2&gt;

&lt;p&gt;Lettuce是一个开源的redis client，由javg编写。其主要的宣传特性是线程安全、支持同步异步以及reactive api、支持单实例redis、redis sentinel、redis cluster等。&lt;/p&gt;

&lt;p&gt;Lettuce的实现主要是基于netty实现了网络层逻辑，通过专门的设计支持在同一个连接上并发的处理多个请求响应。&lt;/p&gt;

&lt;h2 id=&quot;使用实例&quot;&gt;使用实例&lt;/h2&gt;

&lt;p&gt;1、 添加依赖&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.lettuce&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lettuce-core&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${lettuce.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、创建RedisClient并执行命令&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//创建客户端，也可以与Spring集成&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RedisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://password@localhost:6379/0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StatefulRedisConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获取同步API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syncCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;syncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, Redis!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获取异步API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisAsyncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;asyncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenAccept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the result is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;//获取reactive API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisReactiveCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reactiveCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reactive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reactiveCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the result is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//关闭连接和客户端&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;statefulredisconnection&quot;&gt;StatefulRedisConnection&lt;/h2&gt;

&lt;p&gt;StatefulRedisConnection是一个接口，它代表客户端与服务端的一个连接，同步、异步和reactive三种api底层都是通过StatefulRedisConnection与服务端通信。&lt;/p&gt;

&lt;h3 id=&quot;连接的创建&quot;&gt;连接的创建&lt;/h3&gt;

&lt;p&gt;连接的创建由RedisClient的connect方法执行，connect方法需要传入编解码所需的codec与服务端的URI。codec可以不需要指定，默认是StringCodec.UTF8。connect方法最终会调用到connectStandaloneAsync方法，在这里执行真正的连接创建逻辑，主要包含三个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DefaultEndpoint对象，DefaultEndpoint包含了连接自身的管理以及向对端发送命令的逻辑。&lt;/li&gt;
  &lt;li&gt;创建StatefulRedisConnectionImpl对象，它是StatefulRedisConnection的实际实现。&lt;/li&gt;
  &lt;li&gt;调用connectStatefulAsync方法进行实际的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;connectStatefulAsync方法中首先会创建ConnectionBuilder对象，其中包含了连接的各个选项，比如连接地址、netty相关的配置等等。接着会通过解析redis uri获得一个socketAddress，然后触发initializeChannelAsync0方法中的netty的connect操作，于是连接就建立了。&lt;/p&gt;

&lt;h3 id=&quot;连接状态的管理&quot;&gt;连接状态的管理&lt;/h3&gt;

&lt;p&gt;lettuce是基于netty实现的，所以它在netty的channel上添加了几个自定义的handler，其中具体包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ChannelGroupHandler，用于维护channelGroup的状态，主要逻辑就是在连接建立或者断开时将对应的连接添加到channelGroup或者从channelGroup中移除&lt;/li&gt;
  &lt;li&gt;CommandEncoder，用于redis command的编码&lt;/li&gt;
  &lt;li&gt;CommandHandler，lettuce的核心handler，主要负责redis command发送以及服务端响应的解析&lt;/li&gt;
  &lt;li&gt;ConnectionWatchdog，用于监控连接状态和连接的自动重连&lt;/li&gt;
  &lt;li&gt;ConnectionEventTrigger，用于转发channel的状态事件，对外暴露出listener，用户可以借此监听连接变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;连接状态的管理主要有ChannelGroupHandler与ConnectionWatchDog实现，其中ChannelGroupHandler的逻辑比较简单，ConnectionWatchDog的实现主要是监听channelInactive事件，然后提交一个重连任务到线程池。&lt;/p&gt;

&lt;p&gt;此外，DefaultEndpoint也会监听连接状态的变化，实际上整个通信过程中与服务端的连接由DefaultEndpoint对象持有，当发生连接变化（比如断开或者重连）时，DefaultEndpoint会根据连接的状态执行不同的逻辑，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当连接建立时，将持有的连接对象替换成新建立的连接&lt;/li&gt;
  &lt;li&gt;当发送数据时，先判断连接的状态，如果连接正常则直接通过连接发送；否则将数据添加到自身的缓冲里&lt;/li&gt;
  &lt;li&gt;当连接重连时，将缓冲的数据发送出去，并将持有的连接对象替换成新建立的连接&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;commandhandler&quot;&gt;CommandHandler&lt;/h2&gt;

&lt;p&gt;CommandHandler是lettuce的核心部分，它自身也是一个channel handler，拦截了redis command的write和服务端响应的read等逻辑。&lt;/p&gt;

&lt;h3 id=&quot;发送command&quot;&gt;发送command&lt;/h3&gt;

&lt;p&gt;CommandHandler内部维护了一个command queue，所有发出的command都在这个queue中保存。当执行命令时，CommandHandler会拦截write方法，将其保存到queue中。&lt;/p&gt;

&lt;h3 id=&quot;读取响应&quot;&gt;读取响应&lt;/h3&gt;

&lt;p&gt;当收到来自服务端的响应时，CommandHandler就从queue head取出command然后进行解析，解析成功后command就执行完毕，这时将其从queue中移除即可，如果还有剩余的数据，就继续从queue中取出command进行解析。值得注意的是CommandHandler采用了buffer的方案来处理可能的TCP粘包拆包问题，其内部维护了一个单独的buffer，每次接收到服务端的数据时并不直接进行解析，而是先将其写入到自身的buffer中，然后对buffer的数据进行解析，而每次解析时会尽可能的消费buffer中的所有数据。&lt;/p&gt;

&lt;h2 id=&quot;command的编解码&quot;&gt;command的编解码&lt;/h2&gt;

&lt;p&gt;command的编码在CommandEncoder中触发，其逻辑也比较简单，就是直接调用了command的encode方法。对于服务端响应的解析则直接位于CommandHandler的channelRead方法中。command的编解码也就是直接实现了redis的通信协议，具体可以参考：&lt;a href=&quot;http://redisdoc.com/topic/protocol.html&quot;&gt;redis通信协议&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api的实现&quot;&gt;API的实现&lt;/h2&gt;

&lt;h3 id=&quot;异步api&quot;&gt;异步API&lt;/h3&gt;

&lt;p&gt;在对外API的实现方面，主要逻辑由以下几步构成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;组装命令对应的Command对象，包括命令的类型、命令的参数、命令的返回类型等&lt;/li&gt;
  &lt;li&gt;通过StatefulRedisConnection的dispatch方法发送命令，dispatch方法实际上也就是调用了channel的write方法&lt;/li&gt;
  &lt;li&gt;返回对应的Command对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在异步API的实现中，返回的是一个AsyncCommand对象，AsyncCommand继承了CompletableFuture类型，所以可以作为一个Future返回。AsyncCommand内维护了原始的命令以及返回值的占位符，当解析完成后AsyncCommand就会调用其自身的compelte方法，调用就完成了。&lt;/p&gt;

&lt;h3 id=&quot;同步api&quot;&gt;同步API&lt;/h3&gt;

&lt;p&gt;同步API的实现实际上就是封装了异步调用的API，在返回前阻塞调用Future的get方法。&lt;/p&gt;

&lt;h3 id=&quot;reactive-api&quot;&gt;reactive API&lt;/h3&gt;

&lt;p&gt;reactive API的实现底层也是调用了StatefulRedisConnection的dispatch方法发送命令，然后将返回包装成一个Publisher。&lt;/p&gt;</content><author><name></name></author><summary type="html">Lettuce简介</summary></entry><entry><title type="html">quatrz</title><link href="http://localhost:4000/2019/09/01/Schedule-Task.html" rel="alternate" type="text/html" title="quatrz" /><published>2019-09-01T00:00:00+08:00</published><updated>2019-09-01T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/01/Schedule%20Task</id><content type="html" xml:base="http://localhost:4000/2019/09/01/Schedule-Task.html">&lt;h2 id=&quot;quartz简介&quot;&gt;quartz简介&lt;/h2&gt;

&lt;p&gt;quartz是一个基于java的开源的任务调度框架。&lt;/p&gt;

&lt;h2 id=&quot;quatrz-api&quot;&gt;quatrz API&lt;/h2&gt;

&lt;h3 id=&quot;scheduler&quot;&gt;Scheduler&lt;/h3&gt;

&lt;p&gt;一个Scheduler通过SchedulerFactory创建和销毁。Scheduler提供对Job和Trigger的创建、销毁、暂停等一切调度相关的操作。要启动一个Scheduler，需要显式地调用它的start方法。&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;Job&lt;/h3&gt;

&lt;p&gt;Job是实际的任务执行逻辑的接口，它只有一个方法execute：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;quartz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JobExecutionContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JobExecutionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当一个Job被触发时，Scheduler会重新创建一个Job，然后通过一个worker线程执行Job的execute方法，所以实际的Job实现类中无法维护状态字段。JobExecutionContext包含了一些“运行时”的信息，比如触发Job的Scheduler、触发的Trigger、Job对应的JobDetail等等。JobDetail是在创建Job时构建的包含Job的各种详细信息的对象，其中还包括一个JobDataMap的对象，JobDataMap中存储了Job的各种状态信息。&lt;/p&gt;

&lt;h3 id=&quot;trigger&quot;&gt;Trigger&lt;/h3&gt;

&lt;p&gt;Trigger的作用就是触发Job的执行，其中包含了触发时间、触发周期等相关信息。Trigger也有对应的JobDataMap对象，可以用于向Job传递某些参数。Trigger有不同的实现类型，比如SimpleTrigger和CronTrigger。SimpleTrigger的触发类似Java中的Schedule线程池，可以支持单次执行和定时重复执行等；CronTrigger则支持通过cron表达式指定触发时机。&lt;/p&gt;

&lt;p&gt;Trigger包含优先级的概念，当有不同的Trigger在同一时间触发时，quartz会根据其优先级决定触发的顺序，因为在资源不足的情况下，&lt;/p&gt;

&lt;h3 id=&quot;将job和trigger定义分开的原因&quot;&gt;将Job和Trigger定义分开的原因&lt;/h3&gt;

&lt;p&gt;第一个原因，Job和Trigger可以独立存储，并支持多对多的关联，减少重复定义。第二个原因是这样可以降低耦合程度，可以方便后续对Job或者Trigger的编辑和替换。&lt;/p&gt;

&lt;h3 id=&quot;标识&quot;&gt;标识&lt;/h3&gt;

&lt;p&gt;Job和Triiger都有自己的身份标识，身份标识由name和group两部分组成，并规定group+name的组合必须保证在Scheduler范围内唯一。&lt;/p&gt;

&lt;h3 id=&quot;jobdatamap&quot;&gt;JobDataMap&lt;/h3&gt;

&lt;p&gt;每个JobDetail和Trigger都有与其对应的JobDataMap。用户可以在定义JobDetail和Trigger时传入指定的key-value，Job在执行时就可以从JobExecutionContext中获取对应的key-value。此外quartz还支持将JobDataMap中的key-value与Job的属性字段对应起来，只要Job实现类中定义了与JobDataMap中key-value同名的字段，quartz就会通过setter方法将其设置到创建出来的Job实例中。&lt;/p&gt;

&lt;p&gt;quartz还支持Job的持久化，所以在选择要将什么数据存到JobDataMap时要考虑结构变化带来的序列化兼容问题。在Job实现类上加上@PersistJobDataAfterExecution就可以使quartz在任务执行后将JobDataMap更新。@PersistJobDataAfterExecution通常建议和@DisallowConcurrentExecution配合使用，后者会通知quartz不允许并发执行任务，以避免状态同步问题。&lt;/p&gt;

&lt;h3 id=&quot;triggerlistener-和-joblistener&quot;&gt;TriggerListener 和 JobListener&lt;/h3&gt;

&lt;p&gt;quartz提供TriggerLisenter和JobListener，可以在任务触发时获得通知甚至是阻止任务执行。&lt;/p&gt;

&lt;h2 id=&quot;具体逻辑&quot;&gt;具体逻辑&lt;/h2&gt;

&lt;h3 id=&quot;scheduler初始化&quot;&gt;Scheduler初始化&lt;/h3&gt;

&lt;p&gt;Scheduler是通过SchedulerFactory创建的，默认的SchedulerFactory有两种实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;StdSchedulerFactory 标准实现，基于properties文件进行初始化&lt;/li&gt;
  &lt;li&gt;DirectSchedulerFactory 轻量级实现，可以直接通过代码初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stdschedulerfactory&quot;&gt;StdSchedulerFactory&lt;/h4&gt;

&lt;p&gt;StdSchedulerFactory默认会从&lt;em&gt;当前工作路径&lt;/em&gt;查找名为”quartz.properties”的文件进行初始化；如果没有找到，则会用自带的默认配置文件进行初始化，此外用户还可以通过系统属性”org.quartz.properties”额外指定要加载的配置文件的文件名。除了在配置文件中指定具体的配置，用户还可以通过环境变量以及jvm参数(通过-D指定)覆盖默认的选项。下面是默认的配置文件的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.quartz.scheduler.instanceName: DefaultQuartzScheduler
org.quartz.scheduler.rmi.export: false
org.quartz.scheduler.rmi.proxy: false
org.quartz.scheduler.wrapJobExecutionInUserTransaction: false
org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount: 10
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
org.quartz.jobStore.misfireThreshold: 60000
org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到主要有scheduler、threadPool和jobStore相关的配置，更多的配置可以参考quartz的官方文档。&lt;/p&gt;

&lt;p&gt;StdSchedulerFactory返回的Scheduler对象时StdScheduler，而StdScheduler是对QuartzScheduler的简单封装，QuartzScheduler就是quartz中schedule的核心逻辑了。&lt;/p&gt;

&lt;h4 id=&quot;quartzscheduler&quot;&gt;QuartzScheduler&lt;/h4&gt;

&lt;h5 id=&quot;start&quot;&gt;start&lt;/h5&gt;

&lt;p&gt;start方法会启动一个QuartzSchedulerThread，QuartzScheduler所有的触发操作都发生在这个线程。&lt;/p&gt;

&lt;h5 id=&quot;schedulejob&quot;&gt;scheduleJob&lt;/h5&gt;

&lt;p&gt;scheduleJob会将传入的JobDetai和Trigger存放到JobStore中然后触发相应的Listener以及唤醒scheudle线程。&lt;/p&gt;

&lt;h4 id=&quot;quartzschedulerthread&quot;&gt;QuartzSchedulerThread&lt;/h4&gt;

&lt;p&gt;QuartzScheduleThread相当于一个事件循环，它会在循环中执行以下几个任务：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阻塞等待worker线程池可用&lt;/li&gt;
  &lt;li&gt;从JobStore中获取所有满足触发条件的Trigger&lt;/li&gt;
  &lt;li&gt;调用JobStore的triggersFired方法触发Trigger，注意这里只是触发Trigger，并没有执行对应的Job。这一步的目的主要是在任务执行前给Trigger一个更新自身状态的机会。&lt;/li&gt;
  &lt;li&gt;JobStore触发Trigger后会读取出Trigger对应的Job信息，根据返回的Job信息构建可执行的JobRunShell对象。&lt;/li&gt;
  &lt;li&gt;使用worker线程池执行JobRunShell，也就是执行真正的Job逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;job持久化jobstore&quot;&gt;Job持久化（JobStore）&lt;/h3&gt;

&lt;p&gt;quartz中的JobStore负责储存Job和Trigger定义，它主要与QuartzScheduler交互。按照约定，Job和Trigger的存储都使用group+name的组合作为标识。&lt;/p&gt;

&lt;p&gt;目前quartz提供基于内存的实现以及基于JDBC的实现。基于内存的实现把所有Job和Trigger定义存在内存中，一旦重启所有数据就会丢失；基于JDBC的实现将数据存放在数据库中，同时还支持事务。&lt;/p&gt;</content><author><name></name></author><summary type="html">quartz简介</summary></entry></feed>