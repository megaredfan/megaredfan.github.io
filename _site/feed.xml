<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-10-13T22:17:28+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">熊纪元的博客</title><subtitle>think digital and be human</subtitle><entry><title type="html">cache一致性里的MESI协议</title><link href="http://localhost:4000/2019/10/13/MESI.html" rel="alternate" type="text/html" title="cache一致性里的MESI协议" /><published>2019-10-13T00:00:00+08:00</published><updated>2019-10-13T00:00:00+08:00</updated><id>http://localhost:4000/2019/10/13/MESI</id><content type="html" xml:base="http://localhost:4000/2019/10/13/MESI.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在有多个核的处理器的处理器中，每个核都有自己的cache，而如何确保多个核的cache内容的一致则是一个很容易遇到的问题，MESI协议就是一个专门用来解决cache一致性的协议。很多处理器使用的都是MESI协议或者MESI协议的变体，而MESI协议其实也是MSI协议的变种。MESI协议采用了回写（write-back）的策略来更新cache，使得其性能进一步提高，但也带来了额外的风险，回写带来的问题可以在编写程序时使用内存屏障来规避。&lt;/p&gt;

&lt;h2 id=&quot;mesi协议简介&quot;&gt;MESI协议简介&lt;/h2&gt;

&lt;p&gt;MESI协议名字的由来是由其描述的四个cache状态组成的，分别是M(modified)、E(exclusive)、S(shared)和I(invalid)。各个状态的描述具体如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据已被修改而且与内存中的数据不一致，数据只在当前cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据与内存中的数据一致，数据只在当前cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;当前cache的内容有效，数据与内存中的数据一致，数据在多个cache里存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;当前cache无效&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;状态转移&quot;&gt;状态转移&lt;/h3&gt;

&lt;p&gt;MESI协议其实是一个状态机，cache的状态会跟根据外部事件的刺激而发生转移，具体的事件分为两类：处理器对cache的请求和总线对cache的请求，具体如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PrRd: 处理器请求读一个缓存块&lt;/li&gt;
  &lt;li&gt;PrWr: 处理器请求写一个缓存块&lt;/li&gt;
  &lt;li&gt;BusRd: 窥探器请求指出其他处理器请求读一个缓存块&lt;/li&gt;
  &lt;li&gt;BusRdX: 窥探器请求指出其他处理器请求写一个该处理器不拥有的缓存块&lt;/li&gt;
  &lt;li&gt;BusUpgr: 窥探器请求指出其他处理器请求写一个该处理器拥有的缓存块&lt;/li&gt;
  &lt;li&gt;Flush: 窥探器请求指出请求回写整个缓存到主存&lt;/li&gt;
  &lt;li&gt;FlushOpt: 窥探器请求指出整个缓存块被发到总线以发送给另外一个处理器（缓存到缓存的复制）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而状态之间的转换如下图：
&lt;img src=&quot;/img/Diagrama_MESI.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
   &lt;caption&gt;处理器操作带来的状态转化&lt;/caption&gt;
   &lt;thead&gt;
      &lt;tr&gt;
         &lt;th&gt;初始状态&lt;/th&gt;
         &lt;th&gt;操作&lt;/th&gt;
         &lt;th&gt;响应&lt;/th&gt;
      &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Invalid(I)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;给总线发BusRd信号&lt;/li&gt;
               &lt;li&gt;其他处理器看到BusRd，检查自己是否有有效的数据副本，通知发出请求的缓存&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本，状态转换为(S)&lt;b&gt;Shared&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存都没有有效的副本，状态转换为(E)&lt;b&gt;Exclusive&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 其中一个缓存发出数据；否则从主存获得数据&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;给总线发BusRdX信号&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 其中一个缓存发出数据；否则从主存获得数据&lt;/li&gt;
               &lt;li&gt;如果其他缓存有有效的副本, 见到BusRdX信号后无效其副本&lt;/li&gt;
               &lt;li&gt;向缓存块中写入修改后的值&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Exclusive(E)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;向缓存块中写入修改后的值&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Shared(S)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;发出总线事务BusUpgr信号&lt;/li&gt;
               &lt;li&gt;状态转换为(M)&lt;b&gt;Modified&lt;/b&gt;&lt;/li&gt;
               &lt;li&gt;其他缓存看到BusUpgr总线信号，标记其副本为(I)Invalid.&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Modified(M)&lt;/td&gt;
         &lt;td&gt;PrRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;读操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;PrWr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;无总线事务生成&lt;/li&gt;
               &lt;li&gt;状态保持不变&lt;/li&gt;
               &lt;li&gt;写操作为缓存命中&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;tfoot&gt;&lt;/tfoot&gt;
&lt;/table&gt;

&lt;table&gt;
   &lt;caption&gt;不同总线操作带来的状态转化&lt;/caption&gt;
   &lt;thead&gt;
      &lt;tr&gt;
         &lt;th&gt;初始状态&lt;/th&gt;
         &lt;th&gt;操作&lt;/th&gt;
         &lt;th&gt;响应&lt;/th&gt;
      &lt;/tr&gt;
   &lt;/thead&gt;
   &lt;tbody&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Invalid(I)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态保持不变，信号忽略&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX/BusUpgr&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态保持不变，信号忽略&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Exclusive(E)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Shared(S)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;可能发出总线FlushOpt信号并发出块的内容（设计时决定那个共享的缓存发出数据）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td rowspan=&quot;2&quot;&gt;Modified(M)&lt;/td&gt;
         &lt;td&gt;BusRd&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为共享&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
         &lt;td&gt;BusRdX&lt;/td&gt;
         &lt;td&gt;
            &lt;ul&gt;
               &lt;li&gt;状态变为无效&lt;/li&gt;
               &lt;li&gt;发出总线FlushOpt信号并发出块的内容，接收者为最初发出BusRd的缓存与主存控制器（回写主存）&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/td&gt;
      &lt;/tr&gt;
   &lt;/tbody&gt;
   &lt;tfoot&gt;&lt;/tfoot&gt;
&lt;/table&gt;

&lt;h3 id=&quot;内存屏障的引入&quot;&gt;内存屏障的引入&lt;/h3&gt;

&lt;p&gt;MESI的设计比较简单直接，但是其中有两个地方会导致性能下降：一是更新invalidate状态的cache时，需要尝试从其他cpu甚至是内存获取最新的数据；二是使一个cache变为invalidate时需要等待其他cpu的确认；这两个操作都是比较耗时的，如果cpu在这两个过程中一直等待的话，就会形成浪费。&lt;/p&gt;

&lt;h3 id=&quot;store-buffer&quot;&gt;store buffer&lt;/h3&gt;

&lt;p&gt;为了降低写入invalidate状态的cache的延时，可以引入store buffer。既然写入操作无论如何一定会发生，那么cpu就先发出信号通知其他cpu这个cache已经失效，然后再将本次的写操作更新到store buffer中，等到其他cpu都确认收到信号后再将结果写到内存中。&lt;/p&gt;

&lt;p&gt;这样就避免了更新cache时阻塞等待其他cpu确认的耗时，但是也会导致cpu的更新并没有及时写入cache，所以当cpu需要读取cache时，它需要先确认store buffer中是否有所需的数据，这个机制成为store forwarding。值得注意的是，当cpu在读写自己的store buffer时，对应的数据变更其他cpu是感知不到的。&lt;/p&gt;

&lt;h3 id=&quot;invalidate-queue&quot;&gt;invalidate queue&lt;/h3&gt;

&lt;p&gt;当cpu收到使某个cache失效的消息时，预期的行为是cpu马上执行这个失效操作。但实际上cpu并不会马上执行失效操作，而是先发送确认收到的消息，然后将失效操作加入到invalidate queue中，queue中的操作随后会在适当的时刻执行（并不一定是马上）。之所以需要invalidate queue同样是因为invalidate操作开销比较大，cpu为了执行invalidate操作必须丢弃cache，导致cache命中率下降。这样的好处是能够提高cpu的性能，但同时也导致cache中可能存在过期的数据。&lt;/p&gt;

&lt;h3 id=&quot;内存屏障&quot;&gt;内存屏障&lt;/h3&gt;

&lt;p&gt;针对store buffer和invalidate queue这两个优化带来的问题，我们又提供了内存屏障作为解决方案。内存屏障交给了编写程序的人的手里，利用它就可以规避上面提到的问题。&lt;/p&gt;

&lt;p&gt;内存屏障分为写屏障和读屏障，编写程序时可以在期望的地方加入内存屏障。写屏障会强制cpu清空store buffer的内容，也就是将所有的变更都写入cache，随后变更也就写入了内存，使其对其他cpu可见；读屏障会强制cpu执行invalidate queue中的所有invalidate操作，使自身的cache内容失效，从而使cpu从内存或者其他cpu中获取最新的cache数据。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;MESI协议乍一看和java里的内存模型以及volatile关键字有些相似，后续再详细展开了。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">linux perf</title><link href="http://localhost:4000/2019/09/22/Linux-perf.html" rel="alternate" type="text/html" title="linux perf" /><published>2019-09-22T00:00:00+08:00</published><updated>2019-09-22T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/22/Linux%20perf</id><content type="html" xml:base="http://localhost:4000/2019/09/22/Linux-perf.html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;perf是linux系统中提供的性能分析工具，它基于一个叫“Performance counters”的内核子系统实现，同时支持硬件（CPU、PMU(Performance Monitoring Unit)）和软件(软件计数器、tracepoint)层面的性能分析。&lt;/p&gt;

&lt;h3 id=&quot;perf中的事件&quot;&gt;perf中的事件&lt;/h3&gt;

&lt;p&gt;perf与其他性能调优工具一样，都是通过对监测对象进行采样，根据采样点的分布来推断整个程序的行为。通过perf list命令我们可以看到perf支持很多的采样事件，比如branch-misses、cpu-clock等等。perf中预定义的事件属于不同的类型，比如硬件产生的事件（cache 命中/分支miss）和软件产生的事件（context switch/page fault)等等。&lt;/p&gt;

&lt;h3 id=&quot;tracepoint&quot;&gt;tracepoint&lt;/h3&gt;

&lt;p&gt;tracepoint是linux内核中定义的一些hook，如果被开启，它们就会在执行到特定逻辑时被触发，方便其他工具获取系统内部的运行状态等信息，perf就是利用了tracepoint，它会记录和统计tracepoint的各个事件，生成分析报告。&lt;/p&gt;

&lt;h2 id=&quot;使用方式&quot;&gt;使用方式&lt;/h2&gt;

&lt;p&gt;perf 工具的具体使用方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;perf [--version] [--help] COMMAND [ARGS]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的COMMAND列表可以通过执行perf –help查看，下面列举几个常用的command。&lt;/p&gt;

&lt;h3 id=&quot;perf-stat&quot;&gt;perf stat&lt;/h3&gt;

&lt;p&gt;perf stat的作用是执行一个命令并收集其运行过程中的各个数据，它可以提供一个程序运行情况的总体概览。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user@localhost:~$ perf stat hostname
localhost

 Performance counter stats for 'hostname':

          0.313464      task-clock (msec)         #    0.481 CPUs utilized          
                 2      context-switches          #    0.006 M/sec                  
                 0      cpu-migrations            #    0.000 K/sec                  
               153      page-faults               #    0.488 M/sec                  
           896,723      cycles                    #    2.861 GHz                    
           620,709      instructions              #    0.69  insn per cycle         
           121,143      branches                  #  386.465 M/sec                  
             6,247      branch-misses             #    5.16% of all branches        

       0.000651441 seconds time elapsed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个例子，通过perf stat运行了hostname命令，并将其运行过程中的一些指标汇总显示了出来，比如task-clock、context-switches等待。默认情况下，perf stat 会输出几个常用的事件的统计，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;task-clock-msecs：cpu 使用率&lt;/li&gt;
  &lt;li&gt;context-switches：进程切换次数&lt;/li&gt;
  &lt;li&gt;page-faults：发生缺页的次数&lt;/li&gt;
  &lt;li&gt;cpu-migrations：表示进程运行过程中发生了多少次CPU迁移，即被调度器从一个CPU转移到另外一个CPU上运行&lt;/li&gt;
  &lt;li&gt;cycles：处理器时钟，一条机器指令可能需要多个cycles&lt;/li&gt;
  &lt;li&gt;instructions: 机器指令数目&lt;/li&gt;
  &lt;li&gt;branches：遇到的分支指令数&lt;/li&gt;
  &lt;li&gt;branch-misses是预测错误的分支指令数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，我们可以使用-e参数来指定我们感兴趣的事件，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user@localhost:~$ perf stat -e cache-misses hostname
localhost

 Performance counter stats for 'hostname':

          682      cache-misses                                                

       0.000646676 seconds time elapsed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;perf-top&quot;&gt;perf top&lt;/h3&gt;

&lt;p&gt;perf top的作用是实时地显示系统当前的性能统计信息。前面的perf stat用于对一个特定的程序进行分析，而某些时候我们可能并不知道是哪个程序影响了系统性能，这时候就可以用perf top来查找可疑的程序。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Samples: 775  of event 'cpu-clock', Event count (approx.): 92931021
Overhead  Shared Object       Symbol
   8.93%  [kernel]            [k] vsnprintf
   7.73%  perf                [.] rb_next
   5.92%  [kernel]            [k] kallsyms_expand_symbol.clone.0
   5.07%  [kernel]            [k] format_decode
   4.59%  [kernel]            [k] number
   3.40%  perf                [.] symbols__insert
   3.03%  libslang.so.2.2.1   [.] SLtt_smart_puts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的例子显示perf统计了cpu-clock事件的数据，根据比例进行了排序。和perf stat一样，我们可以通过-e参数指定统计其他的事件，比如perf top -e context-switches可以查看进程切换最多的top N个进程。&lt;/p&gt;

&lt;h3 id=&quot;perf-record--perf-report&quot;&gt;perf record &amp;amp; perf report&lt;/h3&gt;

&lt;p&gt;perf record的作用和perf stat类似，它可以运行一个命令并生成统计信息，不过perf record不会将结果显示出来，而是将结果输出到文件中。perf record生成的文件可以用perf report来进行解析。&lt;/p&gt;

&lt;p&gt;perf record还可以通过-g参数，在分析时生成calling graph，帮助定位更上层的逻辑分布。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;通过例子我们可以发现，perf的分析结果中的Symbol一列显示的都是c语言函数的名字。对于java来说，jit编译产生的函数就会直接显示在symbol里，而不是java的函数名，这时要定位问题就不是那么容易了，我们需要通过额外的手段将symbol和java程序的符号表对应起来，具体后续再讨论了。&lt;/p&gt;</content><author><name></name></author><summary type="html">简介</summary></entry><entry><title type="html">Lettuce学习笔记</title><link href="http://localhost:4000/2019/09/08/Lettuce.html" rel="alternate" type="text/html" title="Lettuce学习笔记" /><published>2019-09-08T00:00:00+08:00</published><updated>2019-09-08T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/08/Lettuce</id><content type="html" xml:base="http://localhost:4000/2019/09/08/Lettuce.html">&lt;h2 id=&quot;lettuce简介&quot;&gt;Lettuce简介&lt;/h2&gt;

&lt;p&gt;Lettuce是一个开源的redis client，由javg编写。其主要的宣传特性是线程安全、支持同步异步以及reactive api、支持单实例redis、redis sentinel、redis cluster等。&lt;/p&gt;

&lt;p&gt;Lettuce的实现主要是基于netty实现了网络层逻辑，通过专门的设计支持在同一个连接上并发的处理多个请求响应。&lt;/p&gt;

&lt;h2 id=&quot;使用实例&quot;&gt;使用实例&lt;/h2&gt;

&lt;p&gt;1、 添加依赖&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.lettuce&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lettuce-core&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${lettuce.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、创建RedisClient并执行命令&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//创建客户端，也可以与Spring集成&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RedisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://password@localhost:6379/0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StatefulRedisConnection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获取同步API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syncCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;syncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, Redis!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//获取异步API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisAsyncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;asyncCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;asyncCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenAccept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the result is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;//获取reactive API&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RedisReactiveCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reactiveCommands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;reactive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;reactiveCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;the result is &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//关闭连接和客户端&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;redisClient&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;shutdown&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;statefulredisconnection&quot;&gt;StatefulRedisConnection&lt;/h2&gt;

&lt;p&gt;StatefulRedisConnection是一个接口，它代表客户端与服务端的一个连接，同步、异步和reactive三种api底层都是通过StatefulRedisConnection与服务端通信。&lt;/p&gt;

&lt;h3 id=&quot;连接的创建&quot;&gt;连接的创建&lt;/h3&gt;

&lt;p&gt;连接的创建由RedisClient的connect方法执行，connect方法需要传入编解码所需的codec与服务端的URI。codec可以不需要指定，默认是StringCodec.UTF8。connect方法最终会调用到connectStandaloneAsync方法，在这里执行真正的连接创建逻辑，主要包含三个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建DefaultEndpoint对象，DefaultEndpoint包含了连接自身的管理以及向对端发送命令的逻辑。&lt;/li&gt;
  &lt;li&gt;创建StatefulRedisConnectionImpl对象，它是StatefulRedisConnection的实际实现。&lt;/li&gt;
  &lt;li&gt;调用connectStatefulAsync方法进行实际的连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;connectStatefulAsync方法中首先会创建ConnectionBuilder对象，其中包含了连接的各个选项，比如连接地址、netty相关的配置等等。接着会通过解析redis uri获得一个socketAddress，然后触发initializeChannelAsync0方法中的netty的connect操作，于是连接就建立了。&lt;/p&gt;

&lt;h3 id=&quot;连接状态的管理&quot;&gt;连接状态的管理&lt;/h3&gt;

&lt;p&gt;lettuce是基于netty实现的，所以它在netty的channel上添加了几个自定义的handler，其中具体包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ChannelGroupHandler，用于维护channelGroup的状态，主要逻辑就是在连接建立或者断开时将对应的连接添加到channelGroup或者从channelGroup中移除&lt;/li&gt;
  &lt;li&gt;CommandEncoder，用于redis command的编码&lt;/li&gt;
  &lt;li&gt;CommandHandler，lettuce的核心handler，主要负责redis command发送以及服务端响应的解析&lt;/li&gt;
  &lt;li&gt;ConnectionWatchdog，用于监控连接状态和连接的自动重连&lt;/li&gt;
  &lt;li&gt;ConnectionEventTrigger，用于转发channel的状态事件，对外暴露出listener，用户可以借此监听连接变化&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;连接状态的管理主要有ChannelGroupHandler与ConnectionWatchDog实现，其中ChannelGroupHandler的逻辑比较简单，ConnectionWatchDog的实现主要是监听channelInactive事件，然后提交一个重连任务到线程池。&lt;/p&gt;

&lt;p&gt;此外，DefaultEndpoint也会监听连接状态的变化，实际上整个通信过程中与服务端的连接由DefaultEndpoint对象持有，当发生连接变化（比如断开或者重连）时，DefaultEndpoint会根据连接的状态执行不同的逻辑，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当连接建立时，将持有的连接对象替换成新建立的连接&lt;/li&gt;
  &lt;li&gt;当发送数据时，先判断连接的状态，如果连接正常则直接通过连接发送；否则将数据添加到自身的缓冲里&lt;/li&gt;
  &lt;li&gt;当连接重连时，将缓冲的数据发送出去，并将持有的连接对象替换成新建立的连接&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;commandhandler&quot;&gt;CommandHandler&lt;/h2&gt;

&lt;p&gt;CommandHandler是lettuce的核心部分，它自身也是一个channel handler，拦截了redis command的write和服务端响应的read等逻辑。&lt;/p&gt;

&lt;h3 id=&quot;发送command&quot;&gt;发送command&lt;/h3&gt;

&lt;p&gt;CommandHandler内部维护了一个command queue，所有发出的command都在这个queue中保存。当执行命令时，CommandHandler会拦截write方法，将其保存到queue中。&lt;/p&gt;

&lt;h3 id=&quot;读取响应&quot;&gt;读取响应&lt;/h3&gt;

&lt;p&gt;当收到来自服务端的响应时，CommandHandler就从queue head取出command然后进行解析，解析成功后command就执行完毕，这时将其从queue中移除即可，如果还有剩余的数据，就继续从queue中取出command进行解析。值得注意的是CommandHandler采用了buffer的方案来处理可能的TCP粘包拆包问题，其内部维护了一个单独的buffer，每次接收到服务端的数据时并不直接进行解析，而是先将其写入到自身的buffer中，然后对buffer的数据进行解析，而每次解析时会尽可能的消费buffer中的所有数据。&lt;/p&gt;

&lt;h2 id=&quot;command的编解码&quot;&gt;command的编解码&lt;/h2&gt;

&lt;p&gt;command的编码在CommandEncoder中触发，其逻辑也比较简单，就是直接调用了command的encode方法。对于服务端响应的解析则直接位于CommandHandler的channelRead方法中。command的编解码也就是直接实现了redis的通信协议，具体可以参考：&lt;a href=&quot;http://redisdoc.com/topic/protocol.html&quot;&gt;redis通信协议&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;api的实现&quot;&gt;API的实现&lt;/h2&gt;

&lt;h3 id=&quot;异步api&quot;&gt;异步API&lt;/h3&gt;

&lt;p&gt;在对外API的实现方面，主要逻辑由以下几步构成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;组装命令对应的Command对象，包括命令的类型、命令的参数、命令的返回类型等&lt;/li&gt;
  &lt;li&gt;通过StatefulRedisConnection的dispatch方法发送命令，dispatch方法实际上也就是调用了channel的write方法&lt;/li&gt;
  &lt;li&gt;返回对应的Command对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在异步API的实现中，返回的是一个AsyncCommand对象，AsyncCommand继承了CompletableFuture类型，所以可以作为一个Future返回。AsyncCommand内维护了原始的命令以及返回值的占位符，当解析完成后AsyncCommand就会调用其自身的compelte方法，调用就完成了。&lt;/p&gt;

&lt;h3 id=&quot;同步api&quot;&gt;同步API&lt;/h3&gt;

&lt;p&gt;同步API的实现实际上就是封装了异步调用的API，在返回前阻塞调用Future的get方法。&lt;/p&gt;

&lt;h3 id=&quot;reactive-api&quot;&gt;reactive API&lt;/h3&gt;

&lt;p&gt;reactive API的实现底层也是调用了StatefulRedisConnection的dispatch方法发送命令，然后将返回包装成一个Publisher。&lt;/p&gt;</content><author><name></name></author><summary type="html">Lettuce简介</summary></entry><entry><title type="html">quatrz</title><link href="http://localhost:4000/2019/09/01/Schedule-Task.html" rel="alternate" type="text/html" title="quatrz" /><published>2019-09-01T00:00:00+08:00</published><updated>2019-09-01T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/01/Schedule%20Task</id><content type="html" xml:base="http://localhost:4000/2019/09/01/Schedule-Task.html">&lt;h2 id=&quot;quartz简介&quot;&gt;quartz简介&lt;/h2&gt;

&lt;p&gt;quartz是一个基于java的开源的任务调度框架。&lt;/p&gt;

&lt;h2 id=&quot;quatrz-api&quot;&gt;quatrz API&lt;/h2&gt;

&lt;h3 id=&quot;scheduler&quot;&gt;Scheduler&lt;/h3&gt;

&lt;p&gt;一个Scheduler通过SchedulerFactory创建和销毁。Scheduler提供对Job和Trigger的创建、销毁、暂停等一切调度相关的操作。要启动一个Scheduler，需要显式地调用它的start方法。&lt;/p&gt;

&lt;h3 id=&quot;job&quot;&gt;Job&lt;/h3&gt;

&lt;p&gt;Job是实际的任务执行逻辑的接口，它只有一个方法execute：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;quartz&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JobExecutionContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JobExecutionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当一个Job被触发时，Scheduler会重新创建一个Job，然后通过一个worker线程执行Job的execute方法，所以实际的Job实现类中无法维护状态字段。JobExecutionContext包含了一些“运行时”的信息，比如触发Job的Scheduler、触发的Trigger、Job对应的JobDetail等等。JobDetail是在创建Job时构建的包含Job的各种详细信息的对象，其中还包括一个JobDataMap的对象，JobDataMap中存储了Job的各种状态信息。&lt;/p&gt;

&lt;h3 id=&quot;trigger&quot;&gt;Trigger&lt;/h3&gt;

&lt;p&gt;Trigger的作用就是触发Job的执行，其中包含了触发时间、触发周期等相关信息。Trigger也有对应的JobDataMap对象，可以用于向Job传递某些参数。Trigger有不同的实现类型，比如SimpleTrigger和CronTrigger。SimpleTrigger的触发类似Java中的Schedule线程池，可以支持单次执行和定时重复执行等；CronTrigger则支持通过cron表达式指定触发时机。&lt;/p&gt;

&lt;p&gt;Trigger包含优先级的概念，当有不同的Trigger在同一时间触发时，quartz会根据其优先级决定触发的顺序，因为在资源不足的情况下，&lt;/p&gt;

&lt;h3 id=&quot;将job和trigger定义分开的原因&quot;&gt;将Job和Trigger定义分开的原因&lt;/h3&gt;

&lt;p&gt;第一个原因，Job和Trigger可以独立存储，并支持多对多的关联，减少重复定义。第二个原因是这样可以降低耦合程度，可以方便后续对Job或者Trigger的编辑和替换。&lt;/p&gt;

&lt;h3 id=&quot;标识&quot;&gt;标识&lt;/h3&gt;

&lt;p&gt;Job和Triiger都有自己的身份标识，身份标识由name和group两部分组成，并规定group+name的组合必须保证在Scheduler范围内唯一。&lt;/p&gt;

&lt;h3 id=&quot;jobdatamap&quot;&gt;JobDataMap&lt;/h3&gt;

&lt;p&gt;每个JobDetail和Trigger都有与其对应的JobDataMap。用户可以在定义JobDetail和Trigger时传入指定的key-value，Job在执行时就可以从JobExecutionContext中获取对应的key-value。此外quartz还支持将JobDataMap中的key-value与Job的属性字段对应起来，只要Job实现类中定义了与JobDataMap中key-value同名的字段，quartz就会通过setter方法将其设置到创建出来的Job实例中。&lt;/p&gt;

&lt;p&gt;quartz还支持Job的持久化，所以在选择要将什么数据存到JobDataMap时要考虑结构变化带来的序列化兼容问题。在Job实现类上加上@PersistJobDataAfterExecution就可以使quartz在任务执行后将JobDataMap更新。@PersistJobDataAfterExecution通常建议和@DisallowConcurrentExecution配合使用，后者会通知quartz不允许并发执行任务，以避免状态同步问题。&lt;/p&gt;

&lt;h3 id=&quot;triggerlistener-和-joblistener&quot;&gt;TriggerListener 和 JobListener&lt;/h3&gt;

&lt;p&gt;quartz提供TriggerLisenter和JobListener，可以在任务触发时获得通知甚至是阻止任务执行。&lt;/p&gt;

&lt;h2 id=&quot;具体逻辑&quot;&gt;具体逻辑&lt;/h2&gt;

&lt;h3 id=&quot;scheduler初始化&quot;&gt;Scheduler初始化&lt;/h3&gt;

&lt;p&gt;Scheduler是通过SchedulerFactory创建的，默认的SchedulerFactory有两种实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;StdSchedulerFactory 标准实现，基于properties文件进行初始化&lt;/li&gt;
  &lt;li&gt;DirectSchedulerFactory 轻量级实现，可以直接通过代码初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stdschedulerfactory&quot;&gt;StdSchedulerFactory&lt;/h4&gt;

&lt;p&gt;StdSchedulerFactory默认会从&lt;em&gt;当前工作路径&lt;/em&gt;查找名为”quartz.properties”的文件进行初始化；如果没有找到，则会用自带的默认配置文件进行初始化，此外用户还可以通过系统属性”org.quartz.properties”额外指定要加载的配置文件的文件名。除了在配置文件中指定具体的配置，用户还可以通过环境变量以及jvm参数(通过-D指定)覆盖默认的选项。下面是默认的配置文件的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.quartz.scheduler.instanceName: DefaultQuartzScheduler
org.quartz.scheduler.rmi.export: false
org.quartz.scheduler.rmi.proxy: false
org.quartz.scheduler.wrapJobExecutionInUserTransaction: false
org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount: 10
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
org.quartz.jobStore.misfireThreshold: 60000
org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到主要有scheduler、threadPool和jobStore相关的配置，更多的配置可以参考quartz的官方文档。&lt;/p&gt;

&lt;p&gt;StdSchedulerFactory返回的Scheduler对象时StdScheduler，而StdScheduler是对QuartzScheduler的简单封装，QuartzScheduler就是quartz中schedule的核心逻辑了。&lt;/p&gt;

&lt;h4 id=&quot;quartzscheduler&quot;&gt;QuartzScheduler&lt;/h4&gt;

&lt;h5 id=&quot;start&quot;&gt;start&lt;/h5&gt;

&lt;p&gt;start方法会启动一个QuartzSchedulerThread，QuartzScheduler所有的触发操作都发生在这个线程。&lt;/p&gt;

&lt;h5 id=&quot;schedulejob&quot;&gt;scheduleJob&lt;/h5&gt;

&lt;p&gt;scheduleJob会将传入的JobDetai和Trigger存放到JobStore中然后触发相应的Listener以及唤醒scheudle线程。&lt;/p&gt;

&lt;h4 id=&quot;quartzschedulerthread&quot;&gt;QuartzSchedulerThread&lt;/h4&gt;

&lt;p&gt;QuartzScheduleThread相当于一个事件循环，它会在循环中执行以下几个任务：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阻塞等待worker线程池可用&lt;/li&gt;
  &lt;li&gt;从JobStore中获取所有满足触发条件的Trigger&lt;/li&gt;
  &lt;li&gt;调用JobStore的triggersFired方法触发Trigger，注意这里只是触发Trigger，并没有执行对应的Job。这一步的目的主要是在任务执行前给Trigger一个更新自身状态的机会。&lt;/li&gt;
  &lt;li&gt;JobStore触发Trigger后会读取出Trigger对应的Job信息，根据返回的Job信息构建可执行的JobRunShell对象。&lt;/li&gt;
  &lt;li&gt;使用worker线程池执行JobRunShell，也就是执行真正的Job逻辑。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;job持久化jobstore&quot;&gt;Job持久化（JobStore）&lt;/h3&gt;

&lt;p&gt;quartz中的JobStore负责储存Job和Trigger定义，它主要与QuartzScheduler交互。按照约定，Job和Trigger的存储都使用group+name的组合作为标识。&lt;/p&gt;

&lt;p&gt;目前quartz提供基于内存的实现以及基于JDBC的实现。基于内存的实现把所有Job和Trigger定义存在内存中，一旦重启所有数据就会丢失；基于JDBC的实现将数据存放在数据库中，同时还支持事务。&lt;/p&gt;</content><author><name></name></author><summary type="html">quartz简介</summary></entry><entry><title type="html">Linux磁盘缓存机制</title><link href="http://localhost:4000/2019/08/18/Linux-Disk-Cache.html" rel="alternate" type="text/html" title="Linux磁盘缓存机制" /><published>2019-08-18T00:00:00+08:00</published><updated>2019-08-18T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/18/Linux%20Disk%20Cache</id><content type="html" xml:base="http://localhost:4000/2019/08/18/Linux-Disk-Cache.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近遇到了一起跟磁盘IO相关的线上故障，借此总结一下之前不太了解的Linux磁盘缓存相关的知识。&lt;/p&gt;

&lt;p&gt;总的来说磁盘缓存出现的原因大概有两个：第一是访问磁盘的速度远慢于访问内存的速度，通过在内存中缓存磁盘内容可以提高访问速度；第二是根据程序的局部性原理，数据一旦被访问过，就很有可能在短时间内再次被访问，所以在内存中缓存磁盘内容可以提高程序运行速度。&lt;/p&gt;

&lt;h3 id=&quot;局部性原理&quot;&gt;局部性原理&lt;/h3&gt;

&lt;p&gt;程序局部性原理：程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域，具体来说，局部性通常有两种形式：时间局部性和空间局部性。&lt;/p&gt;

&lt;p&gt;时间局部性：被引用过一次的存储器位置在未来会被多次引用（通常在循环中）。&lt;/p&gt;

&lt;p&gt;空间局部性：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。&lt;/p&gt;

&lt;h2 id=&quot;页缓存&quot;&gt;页缓存&lt;/h2&gt;

&lt;p&gt;Linux系统中为了减少对磁盘的IO操作，会将打开的磁盘内容进行缓存，而缓存的地方则是物理内存，进而将对磁盘的访问转换成对内存的访问，有效提高程序的速度。Linux的缓存方式是利用物理内存缓存磁盘上的内容，称为页缓存（page cache）。&lt;/p&gt;

&lt;p&gt;页缓存是由内存中的物理页面组成的，其内容对应磁盘上的物理块。页缓存的大小会根据系统的内存空闲大小进行动态调整，它可以通过占用内存以扩张大小，也可以自我收缩以缓解内存使用压力。&lt;/p&gt;

&lt;p&gt;在虚拟内存机制出现以前，操作系统使用块缓存系列，但是在虚拟内存出现以后，操作系统管理IO的粒度更大，因此采用了页缓存机制，页缓存是基于页的、面向文件的缓存机制。&lt;/p&gt;

&lt;h3 id=&quot;页缓存的读取&quot;&gt;页缓存的读取&lt;/h3&gt;

&lt;p&gt;Linux系统在读取文件时，会优先从页缓存中读取文件内容，如果页缓存不存在，系统会先从磁盘中读取文件内容更新到页缓存中，然后再从页缓存中读取文件内容并返回。大致过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程调用库函数read发起读取文件请求&lt;/li&gt;
  &lt;li&gt;内核检查已打开的文件列表，调用文件系统提供的read接口&lt;/li&gt;
  &lt;li&gt;找到文件对应的inode，然后计算出要读取的具体的页&lt;/li&gt;
  &lt;li&gt;通过inode查找对应的页缓存，1）如果页缓存节点命中，则直接返回文件内容；2）如果没有对应的页缓存，则会产生一个缺页异常（page fault）。这是系统会创建新的空的页缓存并从磁盘中读取文件内容，更新页缓存，然后重复第4步&lt;/li&gt;
  &lt;li&gt;读取文件返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以说，所有的文件内容的读取，无论最初有没有命中页缓存，最终都是直接来源于页缓存。&lt;/p&gt;

&lt;h3 id=&quot;页缓存的写入&quot;&gt;页缓存的写入&lt;/h3&gt;

&lt;p&gt;因为页缓存的存在，当一个进程调用write时，对文件的更新仅仅是被写到了文件的页缓存中，让后将对应的页标记为dirty，整个过程就结束了。Linux内核会在周期性地将脏页写回到磁盘，然后清理掉dirty标识。&lt;/p&gt;

&lt;p&gt;由于写操作只会把变更写入页缓存，因此进程并不会因此为阻塞直到磁盘IO发生，如果此时计算机崩溃，写操作的变更可能并没有发生在磁盘上。所以对于一些要求比较严格的写操作，比如数据系统，就需要主动调用fsync等操作及时将变更同步到磁盘上。读操作则不同，read通常会阻塞直到进程读取到数据，而为了减少读操作的这种延迟，Linux系统还是用了“预读”的技术，即从磁盘中读取数据时，内核将会多读取一些页到页缓存中。&lt;/p&gt;

&lt;h4 id=&quot;回写线程&quot;&gt;回写线程&lt;/h4&gt;

&lt;p&gt;页缓存的回写是由内核中的单独的线程来完成的，回写线程会在以下3种情况下进行回写：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;空闲内存低于阈值时。当空闲内存不足时，需要释放掉一部分缓存，由于只有不脏的页才能被释放，所以需要把脏页都回写到磁盘，使其变为可回收的干净的页。&lt;/li&gt;
  &lt;li&gt;脏页在内存中处理时间超过阈值时。这是为了确保脏页不会无限期的留在内存中，减少数据丢失的风险。&lt;/li&gt;
  &lt;li&gt;当用户进程调用sync和fsync系统调用时。这是为了给用户进程提供强制回写的方法，满足回写要求严格的使用场景。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;回写线程的实现
|    名称    | 版本 |  说明  |
| ———- | — | —– |
| bdflush |  2.6版本以前 | bdflush 内核线程在后台运行，系统中只有一个 bdflush 线程，当内存消耗到特定阀值以下时，bdflush 线程被唤醒。kupdated 周期性的运行，写回脏页。 但是整个系统仅仅只有一个 bdflush 线程，当系统回写任务较重时，bdflush 线程可能会阻塞在某个磁盘的I/O上，导致其他磁盘的I/O回写操作不能及时执行。|
| pdflush       |  2.6版本引入 | pdflush 线程数目是动态的，取决于系统的I/O负载。它是面向系统中所有磁盘的全局任务的。 但是由于 pdflush 是面向所有磁盘的，所以有可能出现多个 pdflush 线程全部阻塞在某个拥塞的磁盘上，同样导致其他磁盘的I/O回写不能及时执行。|
| flusher线程       |  2.6.32版本以后引入 | flusher 线程的数目不是唯一的，同时flusher线程不是面向所有磁盘的，而是每个flusher线程对应一个磁盘|&lt;/p&gt;

&lt;h3 id=&quot;页缓存的回收&quot;&gt;页缓存的回收&lt;/h3&gt;

&lt;p&gt;Linux中页缓存的替换逻辑是一个修改过的LRU实现，也称为双链策略。和以前不同，Linux维护的不再是一个LRU链表，而是维护两个链表：活跃链表和非活跃链表。处于活跃链表上的页面被认为是“热”的且不会被换出，而在非活跃链表上的页面则是可以被换出的。在活跃链表中的页面必须在其被访问时就处于非活跃链表中。两个链表都被伪LRU规则维护：页面从尾部加入，从头部移除，如同队列。两个链表需要维持平衡–如果活跃链表变得过多而超过了非活跃链表，那么活跃链表的头页面将被重新移回到非活跃链表中，一遍能再被回收。双链表策略解决了传统LRU算法中对仅一次访问的窘境。而且也更加简单的实现了伪LRU语义。这种双链表方式也称作LRU/2。更普遍的是n个链表，故称LRU/n。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;在这次遇到的线上故障中，根本原因在于在业务逻辑中使用了临时文件做缓存，一个临时文件创建后如果在短时间内删除，这时候对这个文件的操作都是在页缓存内进行，不会实际回写到磁盘。当程序出现问题响应变慢时，临时文件存活时间变长，就可能会使其被回写到磁盘上，导致磁盘压力过大，进而影响整个系统。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">netty中的epoll实现</title><link href="http://localhost:4000/2019/08/03/Netty-Epoll.html" rel="alternate" type="text/html" title="netty中的epoll实现" /><published>2019-08-03T00:00:00+08:00</published><updated>2019-08-03T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/03/Netty%20Epoll</id><content type="html" xml:base="http://localhost:4000/2019/08/03/Netty-Epoll.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;在java中，IO多路复用的功能通过nio中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Selector&lt;/code&gt;提供，在不同的操作系统下jdk会通过spi的方式加载不同的实现，比如在macos下是&lt;code class=&quot;highlighter-rouge&quot;&gt;KQueueSelectorProvider&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;KQueueSelectorProvider&lt;/code&gt;底层使用了kqueue来进行IO多路复用；在linux 2.6以后的版本则是&lt;code class=&quot;highlighter-rouge&quot;&gt;EPollSelectorProvider&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;EPollSelectorProvider&lt;/code&gt;底层使用的是epoll。虽然jdk自身提供了selector的epoll实现，netty仍实现了自己的epoll版本，根据&lt;a href=&quot;https://stackoverflow.com/a/23465481&quot;&gt;netty开发者在StackOverflow的回答&lt;/a&gt;，主要原因有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;支持更多socket option，比如TCP_CORK和SO_REUSEPORT&lt;/li&gt;
  &lt;li&gt;使用了边缘触发（ET）模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来就来看看netty自己实现的epoll版本的大概逻辑。&lt;/p&gt;

&lt;h2 id=&quot;总体介绍&quot;&gt;总体介绍&lt;/h2&gt;

&lt;h3 id=&quot;使用方式&quot;&gt;使用方式&lt;/h3&gt;

&lt;p&gt;在netty中，如果需要使用netty自己的epoll实现，需要在项目中添加netty-transport-native-epoll依赖，然后将代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;NioEvnetLoop&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NioSocketChannel&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NioServerSocketChannel&lt;/code&gt;等替换为Epoll开头的类即可。具体参考&lt;a href=&quot;https://netty.io/wiki/native-transports.html&quot;&gt;Using the Linux native transport&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;与jdk原生实现的区别&quot;&gt;与jdk原生实现的区别&lt;/h3&gt;

&lt;p&gt;总的来说，不管是jdk还是netty的版本，都是直接调用了linux的epoll来提供IO多路复用，netty的epoll实现与jdk的区别主要有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用了边缘触发（可以参考我的&lt;a href=&quot;https://juejin.im/post/5cdaa67f518825691b4a5cc0&quot;&gt;另一篇文章&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;使用了eventfd和timerfd来实现唤醒和超时控制，而jdk的实现则是使用了pipe和epoll自带的超时机制&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;具体实现&quot;&gt;具体实现&lt;/h2&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;在初始化时会创建三个fd：epollFd、eventFd、timerFd。epollFd用于进一步调用epoll_wait，而另外两个fd的作用前面已经提到了。除此之外，&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;内部还维护了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;selectStrategy&lt;/code&gt;变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;selectStrategy&lt;/code&gt;用于决定当前的loop中的行为，内容不算复杂，具体的就不再展开了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;还维护了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventArray&lt;/code&gt;类型的对象events，events就是epoll调用时的第二个参数，表示感兴趣的描述符集合，这个变量会被传递到native方法中。&lt;/p&gt;

&lt;p&gt;此外&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;IntObjectMap&amp;lt;AbstractEpollChannel&amp;gt;&lt;/code&gt;类型的channels字段，表示当前EventLoop注册的所有Channel对象，其中key是channel对应的fd（文件描述符），因为epoll中接受的参数和返回的结果都是以整数形式的文件描述符表示的，value就是一个Channel对象，后续对Channel进行读写都会从这里查找（注：这里使用的IntObjectMap是netty自己实现的集合，主要目的是提升使用原生类型作为key或者value时的集合的性能，类似的实现还有hppc、FastUtil等等）。&lt;/p&gt;

&lt;h3 id=&quot;注册感兴趣的连接&quot;&gt;注册感兴趣的连接&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;doRegister&lt;/code&gt;方法中实现了注册连接的逻辑，就是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;方法：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AbstractEpollChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inEventLoop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Native&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;epollCtlAdd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epollFd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AbstractEpollChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channels&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到这里调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Native.epolCtlAdd&lt;/code&gt;，从名字就可以看出来，底层是调用了epoll_ctl方法，然后op参数为EPOLL_ADD。&lt;/p&gt;

&lt;h3 id=&quot;事件循环&quot;&gt;事件循环&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;的主体就在它的&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;方法里，在&lt;code class=&quot;highlighter-rouge&quot;&gt;run&lt;/code&gt;方法的主循环中会先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;selectStrategy&lt;/code&gt;决定要进行的操作是epollWait还是epollBusyWait。epollWait和epollBusyWait的区别就在于前者会计算出适合的超时时间然后调用一次epoll_wait直到有描述符就绪或超时，而后者会循环调用epoll_wait并将超时时间设置为0（也就是立即返回）直到有连接就绪为止。&lt;/p&gt;

&lt;p&gt;通过epollWait或者epollBusyWait获得的结果会保存在events当中，所以接下来就是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;processReady&lt;/code&gt;处理events中的各个就绪的fd。处理的过程就是根据fd从channels查到对应的channel然后进行读写等操作，详细的读写就不再展开介绍了。&lt;/p&gt;

&lt;h3 id=&quot;超时和唤醒&quot;&gt;超时和唤醒&lt;/h3&gt;

&lt;p&gt;前面提到了，netty的epoll逻辑中使用了eventfd和timerfd来实现唤醒和超时控制，evnetfd和timerfd从linux 2.6.22版本开始加入内核，其主要功能就是提供事件通知机制。eventfd可以创建一个文件描述符，在这个描述符上可以传递无符号整数，可以用来作为控制信息。timerfd也是创建一个文件描述符，在这个描述符上可以读取定时器事件，timerfd可以支持到纳秒级别。由于eventfd和timerfd都是基于描述符的，所以和select/poll/epoll这些api都比较契合。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;在初始化时会首先创建epollfd、eventfd和timerfd，然后把eventfd和timerfd都加入到epoll的监听队列当中。eventfd用来做唤醒的支持，当需要唤醒&lt;code class=&quot;highlighter-rouge&quot;&gt;EpollEventLoop&lt;/code&gt;时，就往eventfd写入一个数，这时eventfd就会变得可读，epoll就会及时返回。timerfd则作为epoll的超时控制，当需要超时的时候就在timerfd上设置一个时间间隔，超时时间到了之后timerfd就会变得可读，epoll也就会及时返回。这里使用timerfd作为超时控制而不是使用epoll自带的超时的原因大概有两个，一是使用timerfd可以用统一的处理方式对待超时事件和IO事件，二是timerfd支持的超时时间精度更高。&lt;/p&gt;

&lt;p&gt;顺便提一下，在jdk原生的实现中，唤醒是通过pipe实现的，&lt;code class=&quot;highlighter-rouge&quot;&gt;Selector&lt;/code&gt;内部维护了一个pipe，初始化时将pipe的read端加入epoll的监听队列，当需要唤醒时就在pipe的write端写入数据，这样epoll就会及时返回。epoll返回后如果发现pipe可读，则将pipe中的数据读取完。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;在之前的文章中提到过，将fd注册到epoll时如果采用了边缘触发，那么建议的使用方式是将fd设置为非阻塞模式，并且在描述符就绪时需要将就绪数据全部读取完（遇到EAGAIN）为止，否则可能会出现再也无法收到就绪通知的情况。&lt;/p&gt;

&lt;p&gt;而在netty的epoll实现中，所有的socket都是以ET模式注册的，而eventfd和timerfd则稍有不同。在netty 4.1.38.Final以前的版本，eventfd在注册到epollfd时使用时LT而不是ET，在每次processReady时如果eventfd可读则都会对其调用一次read。timerfd在注册到epollfd时使用的时ET，但是在每次processReady时如果timerfd可读也会对其调用一次read。而在4.1.38.Final版本，eventfd和timerfd都使用了ET，但是并不在processReady方法中读取这两个fd。对于eventfd，会在每次write返回EAGAIN时调用一次read，因为eventfd内部只能存储一个整数，所以当write出现EAGAIN时就说明目前有数据需要读取。而对于timerfd则只会在epollWait出现超时的时候调用一次read，其他情况下不会对timerfd调用read。因为在netty的实现中，每次进行epoll_wait时都会重新设置timerfd的超时时间，而每次更新timerfd的超时时间时，timerfd就会重新变为不可读状态，也就不用对其调用read了。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">linux 线程机制</title><link href="http://localhost:4000/2019/07/28/LinuxThread&NPTL.html" rel="alternate" type="text/html" title="linux 线程机制" /><published>2019-07-28T00:00:00+08:00</published><updated>2019-07-28T00:00:00+08:00</updated><id>http://localhost:4000/2019/07/28/LinuxThread&amp;NPTL</id><content type="html" xml:base="http://localhost:4000/2019/07/28/LinuxThread&amp;NPTL.html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;前面提到进程和线程的区别，进程是资源分配的基本单位，线程是程序执行的基本单位。线程都属于某个进程，而同一个进程下的不同线程分别有共享和独享的数据，这里在列举一下：&lt;/p&gt;

&lt;p&gt;同一进程内的所有线程除了共享全局变量外还共享：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程指令&lt;/li&gt;
  &lt;li&gt;大多数数据&lt;/li&gt;
  &lt;li&gt;打开的文件（即描述符）&lt;/li&gt;
  &lt;li&gt;信号处理函数和信号处置&lt;/li&gt;
  &lt;li&gt;当前工作目录&lt;/li&gt;
  &lt;li&gt;用户ID和组ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过每个线程有各自的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程ID&lt;/li&gt;
  &lt;li&gt;寄存器集合，包括程序计数器和栈指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;信号掩码&lt;/li&gt;
  &lt;li&gt;优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;linux是遵循POSIX标准的操作系统，所以linux也需要提供遵循POSIX标准的线程实现。而最初linux系统中的线程机制则是LinuxThreads，在2.6版本之后又增加了NPTL（Native POSIX Thread Library）。&lt;/p&gt;

&lt;h3 id=&quot;内核线程和用户线程&quot;&gt;内核线程和用户线程&lt;/h3&gt;

&lt;p&gt;对于线程的实现机制来说，通常可以选择在内核内或者内核外实现，这两种方式的区别在于线程是在核内还是核外调度。核内调度更利于并发使用多处理器的资源，内核可以将同一个进程的不同线程调度到不同处理器上执行，当某个线程阻塞时，内核可以将处理器调度到同一个进程的另一个线程。而核外调度的上下文切换开销更低，因为线程的切换不用陷入内核态。&lt;/p&gt;

&lt;h3 id=&quot;进程-线程模型&quot;&gt;进程-线程模型&lt;/h3&gt;

&lt;p&gt;当内核既支持进程也支持线程时，就可以实现线程-进程的”多对多”模型，即一个进程的某个线程由核内调度，而同时它也可以作为用户级线程池的调度者，选择合适的用户级线程在其空间中运行。这样既可满足多处理机系统的需要，也可以最大限度的减小调度开销。&lt;/p&gt;

&lt;p&gt;在内核外实现的线程又可以分为”一对一”、”多对一”两种模型，前者用一个内核进程对应一个线程，将线程调度等同于进程调度，交给内核完成，而后者则完全在核外实现多线程，调度也在用户态完成。后者就是前面提到的单纯的用户级线程模型的实现方式，显然，这种核外的线程调度器实际上只需要完成线程运行栈的切换，调度开销非常小，但同时因为内核信号都是以进程为单位的，因而无法定位到线程，所以这种实现方式不能用于多处理器系统。&lt;/p&gt;

&lt;h3 id=&quot;linux的轻量级进程&quot;&gt;linux的轻量级进程&lt;/h3&gt;

&lt;p&gt;linux内核只提供了轻量进程的支持，限制了更高效的线程模型的实现，但linux着重优化了进程的调度开销，一定程度上也弥补了这一缺陷。目前linux的线程机制都采用的线程-进程”一对一”模型，调度交给内核，而在用户级实现一个包括信号处理在内的线程管理机制。&lt;/p&gt;

&lt;p&gt;linux内核在2.0.x版本就已经实现了轻量进程，应用程序可以通过一个统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;系统调用接口，用不同的参数指定创建轻量进程还是普通进程。在内核中，&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;调用经过参数传递和解释后会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;do_fork&lt;/code&gt;，这个核内函数同时也是&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;vfork&lt;/code&gt;系统调用的最终实现：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;intdo_fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsignedlongclone_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsignedlongstack_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;structpt_regs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsignedlongstack_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;在do_fork&lt;/code&gt;中，不同的clone_flags将导致不同的行为（共享不同的资源），下面列举几个flag的作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLONE_VM&lt;/strong&gt;
如果&lt;code class=&quot;highlighter-rouge&quot;&gt;do_fork&lt;/code&gt;时指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLONE_VM&lt;/code&gt;开关，创建的轻量级进程的内存空间将会和父进程指向同一个地址，即创建的轻量级进程将与父进程共享内存地址空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLONE_FS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;do_fork&lt;/code&gt;时指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLONE_FS&lt;/code&gt;开关，对于轻量级进程则会与父进程共享相同的所在文件系统的根目录和当前目录信息。也就是说，轻量级进程没有独立的文件系统相关的信息，进程中任何一个线程改变当前目录、根目录等信息都将直接影响到其他线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLONE_FILES&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;do_fork&lt;/code&gt;时指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLONE_FILES&lt;/code&gt;开关，创建的轻量级进程与父进程将会共享已经打开的文件。这一共享使得任何线程都能访问进程所维护的打开文件，对它们的操作会直接反映到进程中的其他线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLONE_SIGHAND&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;do_fork&lt;/code&gt;时指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLONE_FILES&lt;/code&gt;开关，轻量级进程与父进程将会共享对信号的处理方式。也就是说，子进程与父进程的信号处理方式完全相同，而且可以相互更改。&lt;/p&gt;

&lt;p&gt;尽管linux支持轻量级进程，但并不能说它就支持内核线程，因为linux的”线程”和”进程”实际上处于一个调度层次，共享一个进程标识符空间，这种限制使得不可能在linux上实现完全意义上的POSIX线程机制，因此众多的linux线程库实现尝试都只能尽可能实现POSIX的绝大部分语义，并在功能上尽可能逼近。&lt;/p&gt;

&lt;h2 id=&quot;linuxthreads的线程机制&quot;&gt;LinuxThreads的线程机制&lt;/h2&gt;

&lt;p&gt;LinuxThreads是linux平台上使用过的一个线程库。它所实现的就是基于内核轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。对于LinuxThreads，它使用&lt;code class=&quot;highlighter-rouge&quot;&gt;(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND)&lt;/code&gt;参数来调用&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;创建”线程”，表示共享内存、共享文件系统访问计数、共享文件描述符表，以及共享信号处理方式。&lt;/p&gt;

&lt;h3 id=&quot;管理线程&quot;&gt;管理线程&lt;/h3&gt;

&lt;p&gt;LinuxThreads最初的设计相信相关进程之间的上下文切换速度很快，因此每个内核线程足以处理很多相关的用户级线程。LinuxThreads非常出名的一个特性就是管理线程（manager thread）。在LinuxThreads中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_create&lt;/code&gt;创建一个线程的时候就会创建并启动管理线程。&lt;/p&gt;

&lt;p&gt;在一个进程空间内，管理线程与其他线程之间通过一对”管理管道（manager_pipe[2]）”来通讯，该管道在创建管理线程之前创建，在成功启动了管理线程之后，管理管道的读端和写端分别赋给两个全局变量&lt;code class=&quot;highlighter-rouge&quot;&gt;__pthread_manager_reader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;__pthread_manager_request&lt;/code&gt;，之后，每个用户线程都通过&lt;code class=&quot;highlighter-rouge&quot;&gt;__pthread_manager_request&lt;/code&gt;向管理线程发请求，但管理线程本身并没有直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__pthread_manager_reader&lt;/code&gt;，管道的读端（manager_pipe[0]）是作为&lt;code class=&quot;highlighter-rouge&quot;&gt;__clone()&lt;/code&gt;的参数之一传给管理线程的，管理线程的工作主要就是监听管道读端，并对从中取出的请求作出反应。&lt;/p&gt;

&lt;p&gt;管理线程在进行一系列初始化工作后，进入while(1)循环。在循环中，线程以2秒为timeout查询（__poll()）管理管道的读端。在处理请求前，检查其父线程是否已退出，如果已退出就退出整个进程。如果有退出的子线程需要清理，则进行清理。然后才是读取管道中的请求，根据请求类型执行相应操作（switch-case）。&lt;/p&gt;

&lt;p&gt;每个LinuxThreads线程都同时具有线程id和进程id，其中进程id就是内核所维护的进程号，而线程id则由LinuxThreads分配和维护。&lt;/p&gt;

&lt;h3 id=&quot;linuxthreads的局限性&quot;&gt;LinuxThreads的局限性&lt;/h3&gt;

&lt;p&gt;LinuxThreads的设计通常都可以很好地工作；但是在压力很大的应用程序中，它的性能、可伸缩性和可用性都会存在问题。下面让我们来看一下LinuxThreads设计的一些局限性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程id问题：linux内核并不支持真正意义上的线程，LinuxThreads是用与普通进程具有同样内核调度视图的轻量级进程来实现线程支持的。这些轻量级进程拥有独立的进程id，在进程调度、信号处理、IO等方面享有与普通进程一样的能力。在源码阅读者看来，就是linux内核的&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;没有实现对CLONE_PID参数的支持。按照POSIX定义，同一进程的所有线程应该共享一个进程id和父进程id，这在目前的”一对一”模型下是无法实现的。&lt;/li&gt;
  &lt;li&gt;管理线程容易成为瓶颈，这是这种结构的通病；同时，管理线程又负责用户线程的清理工作，因此，尽管管理线程已经屏蔽了大部分的信号，但一旦管理线程死亡，用户线程就不得不手工清理了，而且用户线程并不知道管理线程的状态，之后的线程创建等请求将无人处理。&lt;/li&gt;
  &lt;li&gt;信号用来实现同步原语，这会影响操作的响应时间。另外，将信号发送到主进程的概念也并不存在。因此，这并不遵守POSIX中处理信号的方法。&lt;/li&gt;
  &lt;li&gt;LinuxThreads中对信号的处理是按照每线程的原则建立的，而不是按照每进程的原则建立的，这是因为每个线程都有一个独立的进程ID。由于信号被发送给了一个专用的线程，因此信号是串行化的——也就是说，信号是透过这个线程再传递给其他线程的。这与POSIX标准对线程进行并行处理的要求形成了鲜明的对比。例如，在LinuxThreads中，通过kill()所发送的信号被传递到一些单独的线程，而不是集中整体进行处理。这意味着如果有线程阻塞了这个信号，那么LinuxThreads就只能对这个线程进行排队，并在线程开放这个信号时在执行处理，而不是像其他没有阻塞信号的线程中一样立即处理这个信号。&lt;/li&gt;
  &lt;li&gt;由于LinuxThreads中的每个线程都是一个进程，因此用户和组ID的信息可能对单个进程中的所有线程来说都不是通用的。例如，一个多线程的setuid()/setgid()进程对于不同的线程来说可能都是不同的。&lt;/li&gt;
  &lt;li&gt;由于每个线程都是一个单独的进程，因此/proc目录中会充满众多的进程项，而这实际上应该是线程。&lt;/li&gt;
  &lt;li&gt;由于每个线程都是一个进程，因此对每个应用程序只能创建有限数目的线程。&lt;/li&gt;
  &lt;li&gt;由于计算线程本地数据的方法是基于堆栈地址的位置的，因此对于这些数据的访问速度都很慢。另外一个缺点是用户无法可信地指定堆栈的大小，因为用户可能会意外地将堆栈地址映射到本来要为其他目的所使用的区域上了。按需增长（growondemand）的概念（也称为浮动堆栈的概念）是在2.4.10版本的linux内核中实现的。在此之前，LinuxThreads使用的是固定堆栈。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nptl&quot;&gt;NPTL&lt;/h2&gt;

&lt;p&gt;NPTL（Native POSIX Thread Library）是linux线程的一个新实现，它克服了LinuxThreads的缺点，同时也符合POSIX的需求。与LinuxThreads相比，它在性能和稳定性方面都提供了重大的改进。与LinuxThreads一样，NPTL也实现了一对一的模型。&lt;/p&gt;

&lt;p&gt;NPTL出现的一部分原因是对LinuxThreads进行改进，它设计目标如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个新线程库应该兼容POSIX标准。&lt;/li&gt;
  &lt;li&gt;这个线程实现应该在具有很多处理器的系统上也能很好地工作。&lt;/li&gt;
  &lt;li&gt;为一小段任务创建新线程应该具有很低的启动成本。&lt;/li&gt;
  &lt;li&gt;NPTL线程库应该与LinuxThreads是二进制兼容的。&lt;/li&gt;
  &lt;li&gt;这个新线程库应该可以利用NUMA支持的优点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nptl的优点&quot;&gt;NPTL的优点&lt;/h3&gt;

&lt;p&gt;NPTL总的来说采用了LinuxThreads类似的解决办法，内核看到的依然是一个进程，新线程是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;系统调用产生的。与LinuxThreads相比，NPTL具有很多优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NPTL没有使用管理线程。管理线程的一些需求，例如向作为进程一部分的所有线程发送终止信号，是并不需要的；因为内核本身就可以实现这些功能。内核还会处理每个线程堆栈所使用的内存的回收工作。它甚至还通过在清除父线程之前进行等待，从而实现对所有线程结束的管理，这样可以避免僵尸进程的问题。&lt;/li&gt;
  &lt;li&gt;由于NPTL没有使用管理线程，因此其线程模型在NUMA和SMP系统上具有更好的可伸缩性和同步机制。&lt;/li&gt;
  &lt;li&gt;使用NPTL线程库与新内核实现，就可以避免使用信号来对线程进行同步了。为了这个目的，NPTL引入了一种名为&lt;code class=&quot;highlighter-rouge&quot;&gt;futex&lt;/code&gt;的新机制。&lt;code class=&quot;highlighter-rouge&quot;&gt;futex&lt;/code&gt;在共享内存区域上进行工作，因此可以在进程之间进行共享，这样就可以提供进程间POSIX同步机制。我们也可以在进程之间共享一个&lt;code class=&quot;highlighter-rouge&quot;&gt;futex&lt;/code&gt;。这种行为使得进程间同步成为可能。实际上，NPTL包含了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD_PROCESS_SHARED&lt;/code&gt;宏，使得开发人员可以让用户级进程在不同进程的线程之间共享互斥锁。&lt;/li&gt;
  &lt;li&gt;由于NPTL是POSIX兼容的，因此它对信号的处理是按照每进程的原则进行的；getpid()会为所有的线程返回相同的进程ID。例如，如果发送了SIGSTOP信号，那么整个进程都会停止；使用LinuxThreads，只有接收到这个信号的线程才会停止。这样可以在基于NPTL的应用程序上更好地利用调试器，例如GDB。&lt;/li&gt;
  &lt;li&gt;由于在NPTL中所有线程都具有一个父进程，因此对父进程汇报的资源使用情况（例如CPU和内存百分比）都是对整个进程进行统计的，而不是对一个线程进行统计的。&lt;/li&gt;
  &lt;li&gt;NPTL线程库所引入的一个实现特性是对ABI（应用程序二进制接口）的支持。这帮助实现了与LinuxThreads的向后兼容性。这个特性是通过使用&lt;code class=&quot;highlighter-rouge&quot;&gt;LD_ASSUME_KERNEL&lt;/code&gt;实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;futex&quot;&gt;futex&lt;/h3&gt;

&lt;p&gt;futex（Fast Userspace muTexes）意为快速用户区互斥，它是linux提供的一种同步（互斥）机制，特点是对于条件的判断是发生在用户空间的，在竞争不激烈的情况下能有更好的性能表现。futex在2.6.x系列稳定版内核中出现。&lt;/p&gt;

&lt;p&gt;futex由一块能够被多个进程共享的内存空间（一个对齐后的整型变量）组成；这个整型变量的值能够通过汇编语言调用CPU提供的原子操作指令来增加或减少，并且一个进程可以等待直到那个值变成正数。Futex 的操作几乎全部在用户空间完成；只有当操作结果不一致从而需要仲裁时，才需要进入操作系统内核空间执行。这种机制允许使用 futex 的锁定原语有非常高的执行效率：由于绝大多数的操作并不需要在多个进程之间进行仲裁，所以绝大多数操作都可以在应用程序空间执行，而不需要使用（相对高代价的）内核系统调用。&lt;/p&gt;</content><author><name></name></author><summary type="html">前言</summary></entry><entry><title type="html">redis热点</title><link href="http://localhost:4000/2019/07/21/Redis-Hot-Key.html" rel="alternate" type="text/html" title="redis热点" /><published>2019-07-21T00:00:00+08:00</published><updated>2019-07-21T00:00:00+08:00</updated><id>http://localhost:4000/2019/07/21/Redis%20Hot%20Key</id><content type="html" xml:base="http://localhost:4000/2019/07/21/Redis-Hot-Key.html">&lt;h2 id=&quot;redis简介&quot;&gt;redis简介&lt;/h2&gt;

&lt;p&gt;redis是一个用C语言编写的开源的、基于内存的键值对存储数据库。redis支持多种数据结构如string、hash、list、set等等，同时还支持原子操作。相比起其他kv类型的数据库产品，redis有两个突出的特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;redis支持多种数据结构，并且可以在复杂的数据结构上进行原子操作&lt;/li&gt;
  &lt;li&gt;redis支持数据的持久化，包括RDB和AOF格式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外，redis的另一个着重宣传的优势就是快，因为redis对数据的操作都是基于内存的，同时redis采用单线程模型，所有的命令都在同一个线程中执行，避免了线程切换的影响。&lt;/p&gt;

&lt;h2 id=&quot;redis使用的限制&quot;&gt;redis使用的限制&lt;/h2&gt;

&lt;p&gt;由于redis独特的单线程模型，在使用redis时需要注意几个地方，避免出现性能下降。&lt;/p&gt;

&lt;h3 id=&quot;避免耗时的操作&quot;&gt;避免耗时的操作&lt;/h3&gt;

&lt;p&gt;前面提到，redis只用一个线程处理所有的命令，所以应避免出现耗时的操作，否则会阻塞整个redis实例，影响性能。&lt;/p&gt;

&lt;h3 id=&quot;避免大key&quot;&gt;避免大key&lt;/h3&gt;

&lt;p&gt;大key指的是一个key对应的value过大的情况，比如string的长度非常大，或者hash、list、set、zset类型中元素个数非常多等等。redis中的大key会导致查询、删除等操作变慢，网卡带宽占满等问题，影响其他查询。&lt;/p&gt;

&lt;h3 id=&quot;避免keys遍历&quot;&gt;避免KEYS遍历&lt;/h3&gt;

&lt;p&gt;redis中的KEYS命令可以根据给定的正则表达式匹配所有符合的key，时间复杂度为O(N)，在key的数量特别多时耗时会变长，直接导致其他命令阻塞甚至实例崩溃。&lt;/p&gt;

&lt;h2 id=&quot;redis热点产生的原因&quot;&gt;redis热点产生的原因&lt;/h2&gt;

&lt;p&gt;在实际的生产中，我们通常会通过集群的模式部署redis来保证性能和可用性。redis集群的原理是通过分片来扩展服务能力，但不支持同时处理多个key的命令，来自客户端的请求会根据一定的规则路由到集群中的某个实例，而实例与实例之间不进行数据交换。&lt;/p&gt;

&lt;p&gt;热点通常是由实际业务中的热门商品、热点新闻或者突发事件引起的，这是用户会大量而且集中的访问某个数据。而在服务端访问数据时，就会根据数据分片规则访问某个redis实例，这时由于请求过于集中，所有的请求都会落到同一个实例，就产生了redis热点。&lt;/p&gt;

&lt;h2 id=&quot;redis热点的危害&quot;&gt;redis热点的危害&lt;/h2&gt;

&lt;p&gt;redis热点实际上就是某个redis实例的负载过高，进而导致以下几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;主机网卡被打满，影响主机上的其他服务&lt;/li&gt;
  &lt;li&gt;请求量过大，导致redis实例崩溃&lt;/li&gt;
  &lt;li&gt;redis失效导致业务降级到读取DB，进而导致DB也崩溃，业务雪崩&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;redis热点的解决方法&quot;&gt;redis热点的解决方法&lt;/h2&gt;

&lt;h3 id=&quot;避免直接读db&quot;&gt;避免直接读DB&lt;/h3&gt;

&lt;p&gt;这是比较简单的方法，业务的服务端维护一个本地缓存，当redis负载过高或者崩溃时不降级到DB，而是返回本地缓存中的数据。但是这个方案有以下几个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要一个判断是否返回本地缓存的机制&lt;/li&gt;
  &lt;li&gt;需要维护本地缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;读写分离&quot;&gt;读写分离&lt;/h3&gt;

&lt;p&gt;读写分离的方案需要引入一个代理层，在redis客户端与redis集群之间增加一个代理，来自客户端的请求会先经过代理层做负载均衡和路由。然后redis集群中的实例分为读和写两类，读节点只负责读取数据。当出现redis请求热点时，读节点负载就会上升，这是我们可以扩容出更多的读节点来分担负载，避免redis实例崩溃。但是这种方案由以下几个要求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要维护代理层和负载均衡&lt;/li&gt;
  &lt;li&gt;需要实时监控redis负载&lt;/li&gt;
  &lt;li&gt;需要支持节点扩缩容&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;热点数据缓存&quot;&gt;热点数据缓存&lt;/h3&gt;

&lt;p&gt;另一种可以选择的方案就是对热点数据进行缓存，这里可以选择在代理层进行缓存或者是在客户端缓存。当发现有redis热点时，可以及时从缓存读取，避免直接向redis实例发起请求。这个方案有以下几个要求：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要维护本地缓存&lt;/li&gt;
  &lt;li&gt;需要redis热点发现机制&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;热点的发现&quot;&gt;热点的发现&lt;/h3&gt;

&lt;p&gt;热点的发现可以通过统计的方式实现。我们可以在代理层周期统计每个key的访问情况，当超过指定阈值时key就成为了热点key。&lt;/p&gt;</content><author><name></name></author><summary type="html">redis简介</summary></entry><entry><title type="html">POSIX Thread</title><link href="http://localhost:4000/2019/07/07/Thread.html" rel="alternate" type="text/html" title="POSIX Thread" /><published>2019-07-07T00:00:00+08:00</published><updated>2019-07-07T00:00:00+08:00</updated><id>http://localhost:4000/2019/07/07/Thread</id><content type="html" xml:base="http://localhost:4000/2019/07/07/Thread.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在传统的unix模型中，当一个进程需要另一个实体来完成某项任务时，它就&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;一个子进程出来处理，比如在一个网络服务器程序中，父进程&lt;code class=&quot;highlighter-rouge&quot;&gt;accept&lt;/code&gt;一个连接，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;一个子进程，由该子进程处理与连接对端的客户端之间的通信。&lt;/p&gt;

&lt;p&gt;尽管这种范式很久以来一直用得很好，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;调用却存在一些问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;是昂贵的。&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;要把父进程的内存映像复制到子进程中，并在子进程中复制所有描述符。当前的实现使用写时复制（COW）的技术，来避免子进程切实需要自己的副本之前把父进程的数据复制到子进程。然而即使有这样的优化措施，&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;仍然是昂贵的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;返回之后，复制进程需要通过进程间通信（IPC）来传递信息。从父进程传递信息到子进程相当容易，因为子进程将从父进程的数据空间和描述符的副本开始运行，然而从子进程往父进程传递消息却比较费力。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程有助于解决这两个问题。线程有时称为轻量进程（lightweight process），因为线程比进程更轻量。也就是说，线程的创建可能比进程的创建快10~100倍。同一进程内的所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而伴随这种简易性而来的却是同步（synchronization）问题。&lt;/p&gt;

&lt;p&gt;同一进程内的所有线程除了共享全局变量外还共享：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程指令&lt;/li&gt;
  &lt;li&gt;大多数数据&lt;/li&gt;
  &lt;li&gt;打开的文件（即描述符）&lt;/li&gt;
  &lt;li&gt;信号处理函数和信号处置&lt;/li&gt;
  &lt;li&gt;当前工作目录&lt;/li&gt;
  &lt;li&gt;用户ID和组ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过每个线程有各自的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程ID&lt;/li&gt;
  &lt;li&gt;寄存器集合，包括程序计数器和栈指针&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;信号掩码&lt;/li&gt;
  &lt;li&gt;优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文中讲述的是POSIX线程，也成为&lt;code class=&quot;highlighter-rouge&quot;&gt;Pthread&lt;/code&gt;。POSIX线程作为POSIX.1c标准的一部分在1995年得到标准化，大多数unix版本支持这类线程。我们将看到所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Pthread&lt;/code&gt;函数都以&lt;code class=&quot;highlighter-rouge&quot;&gt;ptread_&lt;/code&gt;开头。&lt;/p&gt;

&lt;h2 id=&quot;基本线程函数&quot;&gt;基本线程函数&lt;/h2&gt;

&lt;h3 id=&quot;pthread_create&quot;&gt;pthread_create&lt;/h3&gt;

&lt;p&gt;当一个程序由exec启动执行时，称为初始线程（initial thread）或者主线程（main thread）的单个线程就被创建了，其余线程则由&lt;code class=&quot;highlighter-rouge&quot;&gt;ptread_create&lt;/code&gt;函数创建。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_attr_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个进程内的每个线程都由一个线程ID（thread ID）标识，其数据类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_t&lt;/code&gt;（往往都是   unsigned int）。如果新的线程创建成功，其ID就通过&lt;code class=&quot;highlighter-rouge&quot;&gt;tid&lt;/code&gt;指针返回。&lt;/p&gt;

&lt;p&gt;每个线程都有许多属性（attribute）：优先级、初始栈大小、是否为守护线程等等。我们可以在创建线程时通过初始化一个取代默认设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_attr_t&lt;/code&gt;变量指定这些属性。通常情况我们采用默认的设置，这时我们把&lt;code class=&quot;highlighter-rouge&quot;&gt;attr&lt;/code&gt;参数指定为空指针。&lt;/p&gt;

&lt;p&gt;创建一个线程时我们最后指定的参数是由该线程执行的函数及其参数。该线程通过调用该函数开始执行，然后显式（调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_exit&lt;/code&gt;)或者隐式（函数返回）地终止。该函数的地址由&lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt;参数指定，该函数的唯一调用参数是指针&lt;code class=&quot;highlighter-rouge&quot;&gt;arg&lt;/code&gt;。如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构，然后把这个结构的地址作为单个参数传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意&lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;arg&lt;/code&gt;的声明，&lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt;所指函数作为参数接受一个通用指针（void *），又作为返回值返回一个通用指针（void *）。这时的我们可以把一个指针（它指向我们期望的任何内容）传递给一个线程，又允许线程返回一个指针（它同样指向我们所期望的任何内容）。&lt;/p&gt;

&lt;p&gt;通常情况下Ptread函数的返回值成功时为0，出错时为某个非0值。与套接字及大多数系统调用出错时返回-1并置&lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt;为某个正值的做法不同的是，Pthread函数出错时作为函数返回值返回正值错误指示。举个例子，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_create&lt;/code&gt;因在线程数目上超过某个系统限制而不能创建新线程，函数返回值将是&lt;code class=&quot;highlighter-rouge&quot;&gt;EAGAIN&lt;/code&gt;。Pthread函数不设置&lt;code class=&quot;highlighter-rouge&quot;&gt;errno&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;pthread_join&quot;&gt;pthread_join&lt;/h3&gt;

&lt;p&gt;我们可以通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt;等待一个给定线程终止。对比线程和unix进程，&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_create&lt;/code&gt;类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt;类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;waitpid&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们必须制定要等待的线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;tid&lt;/code&gt;。不幸的是，Pthread没有办法等待任意一个线程（类似在&lt;code class=&quot;highlighter-rouge&quot;&gt;waitpid&lt;/code&gt;中制定参数为-1）。如果&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;指针非空，来自所等待的线程的返回值（一个指向某个对象的指针）将存入&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;所指向的位置。&lt;/p&gt;

&lt;h3 id=&quot;pthread_self&quot;&gt;pthread_self&lt;/h3&gt;

&lt;p&gt;每个线程都有一个在进程内标识自身的ID。线程ID由&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_create&lt;/code&gt;返回，而我们可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt;中使用它。每个线程可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ptread_self&lt;/code&gt;获取自身的线程ID。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对比unix线程，&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_self&lt;/code&gt;类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;getpid&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;pthread_detach&quot;&gt;pthread_detach&lt;/h3&gt;

&lt;p&gt;一个线程或者是可汇合的（joinable，默认值），或者是脱离的（detached）。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对它调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt;。脱离的线程却像守护进程，当它们终止时，所有相关资源都将被释放，我们不能等待它们终止。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_detach&lt;/code&gt;函数把指定的线程变为脱离状态。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pthread_exit&quot;&gt;pthread_exit&lt;/h3&gt;

&lt;p&gt;让一个线程终止的方法之一是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_exit&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果该线程未曾脱离，它的线程ID和退出状态将一直留存到调用进程内某个其他线程对它调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_join&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;指针&lt;code class=&quot;highlighter-rouge&quot;&gt;status&lt;/code&gt;不能指向局部于调用线程的对象，因为线程终止时，这样的对象也会消失。&lt;/p&gt;

&lt;p&gt;让一个线程终止的另外两个方法是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;启动线程的函数（即&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_create&lt;/code&gt;的第三个参数）可以返回。该函数的返回值就是相应线程的终止状态。&lt;/li&gt;
  &lt;li&gt;如果进程的main函数返回或者任何线程调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;，整个进程就终止。其中包括它的任何线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;互斥锁&quot;&gt;互斥锁&lt;/h2&gt;

&lt;p&gt;线程编程称为并发编程（concurrent programming）或者并行编程（parallel programming），因为多个线程可以并发（或者并行）地运行且访问相同的变量。在并发编程中更改同一个变量时可能会产生同步问题，其解决办法是使用一个互斥锁（mutex，表示mutual exclusion）保护共享变量；访问该变量的前提条件是持有该互斥锁。按照Pthread，互斥锁是类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_t&lt;/code&gt;的变量。我们使用以下两个函数为一个互斥锁上锁和解锁。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果试图上锁一个已被另外某个线程锁住的互斥锁，本线程将会被阻塞，直到该互斥锁被解锁为止。&lt;/p&gt;

&lt;p&gt;如果某个互斥锁变量是静态分配的，我们就必须把它初始化为常值&lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/code&gt;。如果我们在共享内存区中分配一个互斥锁，那么必须通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutext_init&lt;/code&gt;函数在运行时将其初始化。&lt;/p&gt;

&lt;p&gt;以下是一个利用互斥锁操作计数器的例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#define NLOOP 5000
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 由线程进行递增操作 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tidA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tidB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 等待线程退出 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 先打印，再递增 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用互斥锁上锁会带来额外的开销，但并不会太大。&lt;/p&gt;

&lt;h2 id=&quot;条件变量&quot;&gt;条件变量&lt;/h2&gt;

&lt;p&gt;互斥锁适合于防止同时访问某个共享变量，但我们需要另外某种在等待期间让我们进入睡眠的方式。条件变量（condition variable）结合互斥锁能够提供这样的功能。互斥锁提供互斥机制，条件变量提供信号机制。&lt;/p&gt;

&lt;p&gt;按照Pthread，条件变量是类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_t&lt;/code&gt;的变量。以下两个函数用来使用条件变量：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_cond_signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下是一个使用条件变量的例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#define NLOOP 5000
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 由线程进行递增操作 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_MUTEX_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter_cond&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PTHREAD_COND_INITIALIZER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tidA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tidB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tidB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 主线程循环等待操作完成 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;doit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* 先打印，再递增 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_cond_signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;主循环阻塞在&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;调用中，等待某个即将终止的线程发送发送信号到与&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;关联的条件变量。主循环只在持有互斥锁期间才检查&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;变量，如果发现无事可做，那么就调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;。该函数把调用线程投入睡眠并释放调用线程持有的互斥锁。此外，当&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;返回时（其他某个线程发送信号到与&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;关联的条件变量之后），该线程再次持有该互斥锁。&lt;/p&gt;

&lt;p&gt;为什么每个条件变量要关联一个互斥锁呢？因为“条件”通常是线程之间共享的某个变量的值。允许不同线程设置和测试该变量要求有一个与该变量关联的互斥锁。举例来说，如果上面的例子中没有使用互斥锁，那么主循环就是这样：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里存在这样的可能：主线程外最后一个线程在主循环测试&lt;code class=&quot;highlighter-rouge&quot;&gt;counter &amp;lt; NLOOP&lt;/code&gt;之后但在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;之前递增了&lt;code class=&quot;highlighter-rouge&quot;&gt;counter&lt;/code&gt;。如果发生这样的情况，最后那个“信号”就丢失了，造成主循环永远阻塞在&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;调用中，等待永远不再发生的某事再次出现。&lt;/p&gt;

&lt;p&gt;同样，要求&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;被调用时其所关联的互斥锁必须是上锁的，该函数作为单个原子操作解锁该互斥锁并把调用线程投入睡眠也是出于这个理由。要是该函数不先解锁该互斥锁，到返回时再给它上锁，调用线程就不得不实现解锁事后上锁该互斥锁，测试变量counter的代码将变为：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NLOOP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_cond_wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_cond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pthread_mutex_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;counter_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然而这里也可能存在：主线程外最后一个线程在主线程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_unlock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_wait&lt;/code&gt;之间终止并递增了counter的值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_signal&lt;/code&gt;通常唤醒等在相应条件变量上的单个线程。有时候一个线程知道自己应该唤醒多个线程，这时它可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_broadcast&lt;/code&gt;唤醒等在相应条件变量上的所有线程。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_cond_broadcast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_cond_timedwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_cond_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_mutex_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timespec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;abstime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_timedwait&lt;/code&gt;允许线程设置一个阻塞时间的限制。&lt;code class=&quot;highlighter-rouge&quot;&gt;abstime&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;timespec&lt;/code&gt;结构，指定该函数必须返回时刻的系统时间，即到时候相应条件变量尚未收到信号的话，就会返回&lt;code class=&quot;highlighter-rouge&quot;&gt;ETIME&lt;/code&gt;错误。&lt;/p&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;abstime&lt;/code&gt;是一个绝对时间（absolute time），而不是一个时间增量（time delta）。这一点不同于&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pselect&lt;/code&gt;。使用绝对时间的优点在于，如果该函数过早返回（可能是因为捕获了某个信号），那么不必改动&lt;code class=&quot;highlighter-rouge&quot;&gt;timespec&lt;/code&gt;结构就可以再次调用该函数；缺点是首次调用该函数之前不得不调用&lt;code class=&quot;highlighter-rouge&quot;&gt;gettimeofday&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;创建一个线程通常比调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;派生一个进程快得多。仅仅这一点就能够体现线程在繁重使用的网络服务器上的优势。&lt;/p&gt;

&lt;p&gt;同一进程内的所有线程共享全局变量和描述符，从而允许不同线程之间共享信息。然而这种共享却引入了同步问题，我们必须使用Pthread同步原语“互斥锁”和“条件变量”来解决。共享数据的同步几乎是每个线程化程序必不可少的部分。&lt;/p&gt;

&lt;p&gt;条件变量必须和互斥锁配合使用，这是规范的一部分。这么规定的原因在于如果不配合互斥锁，条件变量会面临可能的信号丢失的问题。这个信号丢失的问题有个专门的名字，叫做&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-5257/sync-30/index.html&quot;&gt;lost wake-up problem&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;关联到java&quot;&gt;关联到java&lt;/h3&gt;

&lt;p&gt;在java 1.2之后的版本，在java中创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread&lt;/code&gt;，在linux平台下实际上就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Pthread&lt;/code&gt;。可以看出java中Thread的各个属性与Pthread比较类似（但是没有detached属性）。在同步方面，java有自己的同步机制（&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;关键字），并没有直接使用Pthread中的同步原语。java 1.5之后引入的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.concurrent.locks&lt;/code&gt;中的库函数，则与Pthread同步原语有更多的相似的地方。&lt;/p&gt;

&lt;p&gt;另外，java中&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;wait/notify/notifyAll&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Condition&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;await/signal&lt;/code&gt;必须要在同步块中，其道理跟条件变量一样，都是为了避免信号丢失的问题。&lt;/p&gt;</content><author><name></name></author><summary type="html">概述</summary></entry><entry><title type="html">Unix域协议</title><link href="http://localhost:4000/2019/06/28/Unix-Domain-Protol.html" rel="alternate" type="text/html" title="Unix域协议" /><published>2019-06-28T00:00:00+08:00</published><updated>2019-06-28T00:00:00+08:00</updated><id>http://localhost:4000/2019/06/28/Unix%20Domain%20Protol</id><content type="html" xml:base="http://localhost:4000/2019/06/28/Unix-Domain-Protol.html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;如果我们的目的仅是在同一台主机上的不同进程之间进行通信，那么除了TCP/UDP套接字以外我们还可以使用Unix域协议。Unix域协议是IPC（进程间通信）的方式之一，Unix域协议使用套接字API，支持同一台主机的不同进程之间进行通信。直观上来说Unix域协议有点类似使用本地回环接口（lo）的TCP/UDP。但是Unix域协议比起TCP/UDP套接字还有几个其他优势：1.比起TCP协议通常要更快；2.支持在同一台主机上的不同进程之间传递描述符；3.支持传递客户端凭证。&lt;/p&gt;

&lt;p&gt;使用Unix域协议的套接字（以下简称uds[unix domain socket]）用到的API与TCP/UDP套接字API完全一致，即服务端需要进行bind、listen、accpet等操作才能读写，客户端需要先connect才能进行读写。与TCP/UDP套接字不同的一点是uds绑定的地址是一个文件系统的绝对路径，比如”/tmp/myuds”，而TCP/UDP套接字使用的地址则包含了地址和端口号。uds使用的路径并不是普通的文件，需要和uds关联才能对其进行读写。Unix域套接字有两种类型，字节流套接字（类似TCP）和数据报套接字（类似UDP）。&lt;/p&gt;

&lt;h2 id=&quot;相关api&quot;&gt;相关API&lt;/h2&gt;

&lt;h3 id=&quot;unix域协议的地址结构&quot;&gt;unix域协议的地址结构&lt;/h3&gt;

&lt;p&gt;前面提到uds并不使用地址加端口号作为协议地址，而是用一个文件路径来作为地址，所以uds使用的地址结构也有一点不同：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;sockaddr_un&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sa_family_t&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sun_family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 协议族，通常为AF_UNIX或者AF_LOCAL */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;sun_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;104&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* 地址路径 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;uds使用的地址结构叫做sockaddr_un，后面的un即unix，而TCP/UDP套接字使用的地址结构叫做sockaddr_in，in表示internet。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;unix域协议虽然名字里有unix，但它是POSIX的一部分，并不与unix系统强绑定，POSIX将unix域协议重新命名为“本地IPC”，把AF_UNIX改为了AF_LOCAL，但更多的时候我们还是称其为unix域协议，我们常见的linux和macos都支持unix域协议。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;unix域协议配合套接字api&quot;&gt;unix域协议配合套接字API&lt;/h3&gt;

&lt;p&gt;unix域协议的使用方式与TCP/UDP套接字的方式类似，只需要将协议族替换为AF_LOCAL（或者AF_UNIX），然后将地址替换为sockaddr_un即可。下面是一个使用uds进行bind，然后通过getsockname获取套接字名称并打印的例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;unp.h&quot;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_un&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;err_quit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;usage: unixbind &amp;lt;pathname&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//先调用socket创建套接字&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AF_LOCAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOCK_STREAM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//对已存在的路径进行bind会导致失败，所以预先调用unlink删除文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;unlink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//调用bzero初始化地址结构体&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bzero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//设置协议族为AF_LOCAL，AF_UNIX也可以&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sun_family&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AF_LOCAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//设置地址的文件路径&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strncpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sun_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sun_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//调用bind，通过SUN_LEN计算bind所需的长度这个参数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SUN_LEN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//获得socket的名字&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Getsockname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bound name = %s, returned len = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sun_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行上面的程序，我们就可以看到控制台会有类似这样的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bound name = xxx, returned len = yy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序会输出我们绑定的路径以及对应的socket长度，这时候也可以看到对应路径也自动创建了同名的文件。如果用&lt;code class=&quot;highlighter-rouge&quot;&gt;ls -lF&lt;/code&gt;命令查看，可以看到对应的文件类型为socket。&lt;/p&gt;

&lt;h3 id=&quot;socketpair&quot;&gt;socketpair&lt;/h3&gt;

&lt;p&gt;socketpair函数可以创建两个连接起来的unix域套接字：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/socket.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socketpair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;socketpair的参数中family必须为AF_LOCAL，protocol必须为0，type可以为SOCK_STREAM或者SOCK_DGRAM，新创建的两个套接字描述符将作为sockfd[0]和sockfd[1]返回。&lt;/p&gt;

&lt;h3 id=&quot;套接字函数&quot;&gt;套接字函数&lt;/h3&gt;

&lt;p&gt;使用uds时，套接字函数中存在一些差异和限制，具体列举如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有bind创建的路径名默认的权限为0777（所有者、组用户和其他用户都可读、可写、可执行），并按照当前umask进行修正。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;umask和chmod中的权限配合使用，是权限的“补码”。比如在我的电脑上umask的值是022，所以uds创建出来的路径权限为777-022=755，表示所有者可读可写可执行，组用户和其他用户可读可写。而通常新创建的目录默认的权限为0777，新创建的文件默认的权限为0666.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;uds绑定的路径应使用绝对路径。避免使用相对路径的原因是相对路径的解析会依赖调用者的当前路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;POSIX声称使用相对路径绑定到uds将导致不可预计的结果&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;调用conenct时传入的路径必须是和一个已经打开的uds绑定的路径。并且两个套接字的type（数据报或者字节流）必须相同。出错的条件有几个：a)路径已存在，但不是一个uds;b)路径已存在且是一个uds，但是没有与之关联的打开的描述符;c)路径已存在并且是一个打开的uds，但是类型不同。&lt;/li&gt;
  &lt;li&gt;调用connect连接一个uds涉及的权限检查等同于调用open以只读模式访问对应路径。&lt;/li&gt;
  &lt;li&gt;unix域字节流套接字与TCP套接字类似，它们都提供无记录边界的字节流接口。&lt;/li&gt;
  &lt;li&gt;如果对一个uds进行connect时发现监听套接字的队列已满，调用会立即返回一个ECONNECTREFUSED错误；而TCP监听套接字在队列满时则会忽略新到达的SYNC，进而连接发起端发起端进行重试。&lt;/li&gt;
  &lt;li&gt;unix域数据报套接字与UDP套接字类似，它们都提供保留记录边界的不可靠的数据报服务。&lt;/li&gt;
  &lt;li&gt;在未绑定的uds上发送数据不会自动为其绑定一个路径，这一点不同于UDP套接字：在一个未绑定的UDP套接字上发送数据会为其绑定一个临时端口。这意味着除非数据报发送端已经绑定到一个路径，否则数据报接收端无法发回应答数据报。类似的，对于uds的connect调用不会为其绑定一个路径，这一点不同于TCP/UDP。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;什么场景下可以选择uds&quot;&gt;什么场景下可以选择uds&lt;/h2&gt;

&lt;h3 id=&quot;本机通信&quot;&gt;本机通信&lt;/h3&gt;

&lt;p&gt;当我们需要在本机通信时，可以使用uds来代替本地回环接口。uds相比TCP/UDP套接字性能会更好，因为它不需要经过网络协议栈，省去了各种解析和应答等步骤，而是直接在内核拷贝传递数据。比如最近很热的service mesh，业务进程和sidecar就可以通过uds来通信。&lt;/p&gt;

&lt;h3 id=&quot;传递描述符&quot;&gt;传递描述符&lt;/h3&gt;

&lt;p&gt;当我们需要传递描述符时，通常可以使用方法有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;fork调用返回以后，子进程共享父进程的所有描述符&lt;/li&gt;
  &lt;li&gt;exec调用执行后，所有的描述符通常保持打开状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式里，我们可以把描述符从父进程传递到子进程，然而我们也可能需要在子进程传递描述符到父进程。unix系统提供了用于从一个进程向其他任意进程传递描述符的方式，而这两个进程不需要有任何亲缘关系。这种技术要求在两个进程之间创建一个uds，然后使用sendmsg通过这个uds发送特殊结构的消息。这个特殊的消息会由内核处理，把打开的描述符从发送进程传递到接收进程。&lt;/p&gt;

&lt;p&gt;通过uds传递描述符的步骤具体如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个字节流或数据报的uds。这可以通过调用socketpair然后父子进程之间的连接；也可以使用套接字API。通常建议使用字节流套接字而不是数据报套接字，因为使用数据报套接字并没有什么好处，反而还存在数据报被丢弃的可能。&lt;/li&gt;
  &lt;li&gt;发送端打开描述符。uds可以传递各种类型的描述符，而不是仅包括文件描述符。&lt;/li&gt;
  &lt;li&gt;发送端进程创建一个msghdr的结构，其中含有待传递的描述符，然后调用sendmsg将其发送出去。发送一个描述符会使其引用计数加一。&lt;/li&gt;
  &lt;li&gt;接收端进程调用recvmsg在创建的uds上接收描述符。这个过程会在接收进程创建一个新的描述符，然后将其指向和发送进程发送的描述符指向的同一个内核文件选项。所以接收端收到的描述符不同于发送端发送端描述符时很正常的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;msghdr的结构定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * [XSI] Message header for recvmsg and sendmsg calls.
 * Used value-result for recvmsg, value only for sendmsg.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msghdr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] optional address */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;msg_namelen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] size of address */&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;iovec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_iov&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] scatter/gather array */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;msg_iovlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] # elements in msg_iov */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;		&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_control&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] ancillary data, see below */&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;msg_controllen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] ancillary data buffer len */&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;msg_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* [XSI] flags on received message */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体的例子就暂时不列举了。&lt;/p&gt;

&lt;h3 id=&quot;验证发送者的身份&quot;&gt;验证发送者的身份&lt;/h3&gt;

&lt;p&gt;可以用uds传递的另一种辅助数据就是用户凭证。用户凭证的数据结构在不同的操作系统中并不一致，这里就不再详细介绍了。&lt;/p&gt;

&lt;h3 id=&quot;uds的优势&quot;&gt;uds的优势&lt;/h3&gt;

&lt;p&gt;uds是客户端和服务端在同一台主机上的IPC方法之一，与其他IPC方法（pipe，共享内存等）相比，uds的优势在于其使用的API几乎等同于网络通讯中使用的API，与客户端和服务端在同一台主机上的TCP相比，unix域字节流套接字的性能要更优。&lt;/p&gt;

&lt;p&gt;此外，uds还支持传递其他辅助数据，比如描述符和用户凭证。&lt;/p&gt;

&lt;h2 id=&quot;java中的uds&quot;&gt;java中的uds&lt;/h2&gt;

&lt;p&gt;java中并不支持直接使用uds，可能是因为java标榜跨平台，而uds则只在部分操作系统中才能使用。要在java中使用uds，通常需要使用第三方提供的类库，比如著名的网络通讯组件netty就提供了uds通讯的支持。&lt;/p&gt;</content><author><name></name></author><summary type="html">简介</summary></entry></feed>